---
phase: 07-turn-timers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - party/index.ts
  - src/lib/gameLogic.ts
  - src/shared/messages.ts
  - src/shared/types.ts
autonomous: true

must_haves:
  truths:
    - "Server schedules alarm when turn starts in bidding phase"
    - "Alarm fires and AI takes action when player doesn't act in time"
    - "Server cancels/ignores alarm when turn ends normally (bid/dudo/calza)"
    - "Timeout AI makes conservative moves favoring bids over dudo"
  artifacts:
    - path: "party/index.ts"
      provides: "onAlarm lifecycle method, setTurnTimer, handleTurnTimeout"
      contains: "onAlarm"
    - path: "src/lib/gameLogic.ts"
      provides: "generateTimeoutAIMove function for conservative AI"
      exports: ["generateTimeoutAIMove"]
    - path: "src/shared/messages.ts"
      provides: "Updated TURN_TIMEOUT message with bid field"
      contains: "bid: BidSchema.optional()"
    - path: "src/shared/types.ts"
      provides: "wasAutoPlayed field on ServerGameState"
      contains: "wasAutoPlayed"
  key_links:
    - from: "party/index.ts"
      to: "this.room.storage.setAlarm"
      via: "setTurnTimer method"
      pattern: "setAlarm"
    - from: "party/index.ts"
      to: "src/lib/gameLogic.ts"
      via: "import generateTimeoutAIMove"
      pattern: "generateTimeoutAIMove"
---

<objective>
Add server-side turn timer using PartyKit alarms that triggers AI takeover on timeout.

Purpose: Implement server-authoritative turn timing so games don't stall when a player is AFK. The timer must be managed by the server using PartyKit's alarm API to survive room hibernation and ensure all clients see synchronized timeout behavior.

Output: Server schedules alarms at turn start, auto-plays conservative AI move if alarm fires, broadcasts TURN_TIMEOUT with the action taken.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-turn-timers/07-CONTEXT.md
@.planning/phases/07-turn-timers/07-RESEARCH.md

Key decisions from CONTEXT.md:
- Timer pauses during reveal animations (only counts during active decision-making)
- Timeout AI: conservative/safe strategy, favor bids over dudo, call dudo only on >80% probability bid is wrong, never call calza
- 500ms grace period before triggering timeout (network latency compensation)

Key patterns from RESEARCH.md:
- PartyKit alarms: `this.room.storage.setAlarm(timestamp)`, `onAlarm()` lifecycle method
- Only ONE alarm per room - new alarm replaces old
- Cancel by checking game state in onAlarm (if turn already advanced, ignore)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conservative timeout AI to gameLogic.ts</name>
  <files>src/lib/gameLogic.ts</files>
  <action>
Add a new function `generateTimeoutAIMove` that takes the player's hand, current bid, total dice, and isPalifico flag. This function should:

1. If no current bid exists, generate a safe opening bid based on what the player actually has in their hand
2. Calculate probability that current bid is wrong using binomial distribution
3. Only return 'dudo' if probability bid is wrong exceeds 80% threshold
4. Never return 'calza' - too risky for timeout scenarios
5. Otherwise, generate minimum valid bid (increase count by 1 on same value, or same count on next higher value)

The function should be explicitly conservative - it's a penalty for timing out, not a strategic advantage.

Return type: `{ type: 'bid'; bid: Bid } | { type: 'dudo' }`

Helper function needed: `calculateBidFailureProbability(bid, hand, totalDice, isPalifico)` using binomial distribution to calculate P(actual count < bid.count).

For binomial calculation:
- p = probability single unknown die matches (1/6 for aces or palifico, 2/6 otherwise)
- n = total dice minus player's dice
- k = needed matches from unknown dice (bid.count - matches in hand)
- Sum P(X < k) for binomial(n, p)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Verify function exists: `grep -n "generateTimeoutAIMove" src/lib/gameLogic.ts`
  </verify>
  <done>
generateTimeoutAIMove function exported from gameLogic.ts, returns conservative bid or dudo (never calza), uses binomial probability for 80% threshold
  </done>
</task>

<task type="auto">
  <name>Task 2: Update message schema and types for timeout tracking</name>
  <files>src/shared/messages.ts, src/shared/types.ts</files>
  <action>
In src/shared/messages.ts:
1. Update TURN_TIMEOUT message schema to include optional bid field:
```typescript
z.object({
  type: z.literal('TURN_TIMEOUT'),
  playerId: z.string(),
  aiAction: z.enum(['bid', 'dudo']),
  bid: BidSchema.optional(), // Only present when aiAction === 'bid'
  timestamp: TimestampSchema,
})
```

In src/shared/types.ts:
1. Add `lastActionWasTimeout: boolean` to ServerGameState interface (track if last action was AI timeout for UI badge)
2. Ensure turnStartedAt is already present (it is - just verify)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Check schema update: `grep -A5 "TURN_TIMEOUT" src/shared/messages.ts`
Check type update: `grep "lastActionWasTimeout" src/shared/types.ts`
  </verify>
  <done>
TURN_TIMEOUT message includes optional bid field, ServerGameState has lastActionWasTimeout boolean for UI tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement PartyKit alarm-based turn timer in server</name>
  <files>party/index.ts</files>
  <action>
Add alarm-based turn timer to the GameServer class:

1. Import generateTimeoutAIMove from src/lib/gameLogic.ts

2. Add private method `setTurnTimer()`:
   - Check if game is in bidding phase and turnTimeoutMs > 0
   - Calculate alarm time: `Date.now() + this.roomState.settings.turnTimeoutMs + 500` (500ms grace period)
   - Call `await this.room.storage.setAlarm(alarmTime)`

3. Add `async onAlarm()` lifecycle method:
   - Guard: Check roomState and gameState exist
   - Guard: Check phase is 'bidding' (if not, turn already ended - ignore)
   - Guard: Check current turn player is still connected and not eliminated
   - Get current player's hand and generate timeout AI move
   - Apply the move (bid or dudo) using existing handlers' logic
   - Set `gameState.lastActionWasTimeout = true`
   - Broadcast TURN_TIMEOUT message with playerId, aiAction, and bid (if applicable)

4. Update existing handlers to set lastActionWasTimeout = false:
   - handlePlaceBid: set lastActionWasTimeout = false before processing
   - handleCallDudo: set lastActionWasTimeout = false before processing
   - handleCallCalza: set lastActionWasTimeout = false before processing

5. Call setTurnTimer() after:
   - handleRollDice (when transitioning to bidding)
   - handlePlaceBid (new turn started)
   - handleContinueRound (when transitioning to bidding)

6. In handleCallDudo and handleCallCalza, the alarm will naturally be ignored because:
   - Phase changes to 'reveal', so onAlarm check for 'bidding' phase fails
   - No explicit cancellation needed

Important: PartyKit only supports ONE alarm per room. Setting a new alarm cancels the previous one automatically.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Check onAlarm exists: `grep -n "onAlarm" party/index.ts`
Check setTurnTimer exists: `grep -n "setTurnTimer" party/index.ts`
Check setAlarm call: `grep -n "setAlarm" party/index.ts`
  </verify>
  <done>
Server uses PartyKit alarms for turn timeout, onAlarm triggers conservative AI move, TURN_TIMEOUT broadcast with action details, lastActionWasTimeout tracking enabled
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Server starts without errors: `npm run dev` (verify no startup crashes)
3. Grep verifications:
   - `grep -n "generateTimeoutAIMove" src/lib/gameLogic.ts` shows export
   - `grep -n "onAlarm" party/index.ts` shows lifecycle method
   - `grep -n "lastActionWasTimeout" src/shared/types.ts` shows field
</verification>

<success_criteria>
- Server compiles and runs
- generateTimeoutAIMove function exists and is conservative (favors bids, 80% threshold for dudo)
- onAlarm lifecycle method implemented
- setTurnTimer called at appropriate points (after roll, after bid, after continue)
- TURN_TIMEOUT message schema updated with optional bid field
- lastActionWasTimeout field added for UI tracking
</success_criteria>

<output>
After completion, create `.planning/phases/07-turn-timers/07-01-SUMMARY.md`
</output>

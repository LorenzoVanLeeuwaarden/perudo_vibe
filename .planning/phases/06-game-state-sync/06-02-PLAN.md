---
phase: 06-game-state-sync
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/app/room/[code]/page.tsx
  - src/components/GameBoard.tsx
  - src/stores/uiStore.ts
autonomous: true

must_haves:
  truths:
    - "Game transitions from lobby to rolling when GAME_STARTED received"
    - "Players see their own dice after roll"
    - "Current bid displays prominently in center"
    - "Turn indicator shows whose turn it is"
    - "Players can place bids, call dudo, call calza when it is their turn"
    - "Dudo/Calza overlay appears on challenge call"
  artifacts:
    - path: "src/components/GameBoard.tsx"
      provides: "Main game UI during active game"
      min_lines: 100
    - path: "src/app/room/[code]/page.tsx"
      provides: "Game message handling"
      contains: "case 'DICE_ROLLED'"
  key_links:
    - from: "src/app/room/[code]/page.tsx"
      to: "src/components/GameBoard.tsx"
      via: "conditional render when gameState exists"
      pattern: "roomState\\.gameState.*GameBoard"
    - from: "src/components/GameBoard.tsx"
      to: "sendMessage"
      via: "props callback for game actions"
      pattern: "sendMessage.*PLACE_BID"
---

<objective>
Build client-side game message handling and the GameBoard UI component for real-time multiplayer gameplay.

Purpose: Players need to see and interact with the game state during active gameplay. This implements the core game loop UI: rolling dice, seeing bids, placing bids, calling dudo/calza.

Output: GameBoard component with player row, center bid display, my dice display, and action buttons. Room page handles all game-related server messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-game-state-sync/06-CONTEXT.md
@.planning/phases/06-game-state-sync/06-RESEARCH.md
@.planning/phases/06-game-state-sync/06-01-SUMMARY.md

# Key source files
@src/app/room/[code]/page.tsx
@src/components/BidUI.tsx
@src/components/PlayerDiceBadge.tsx
@src/components/SortedDiceDisplay.tsx
@src/components/DudoOverlay.tsx
@src/stores/gameStore.ts
@src/stores/uiStore.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add game message handlers to room page</name>
  <files>src/app/room/[code]/page.tsx, src/stores/uiStore.ts</files>
  <action>
In src/stores/uiStore.ts, add new state for game phase:
- Add `revealedHands: Record<string, number[]> | null` to interface and initial state (null)
- Add `roundResult: { bid: Bid; actualCount: number; loserId: string | null; winnerId: string | null; isCalza: boolean } | null` (null initially)
- Add `setRevealedHands: (hands: Record<string, number[]> | null) => void` action
- Add `setRoundResult: (result: { bid: Bid; actualCount: number; loserId: string | null; winnerId: string | null; isCalza: boolean } | null) => void` action
- Import Bid type from '@/shared/types' (or '@/lib/types' if that's where it's used - check which one BidUI uses)

In src/app/room/[code]/page.tsx, add to JoinState 'joined' status a `myHand: number[]` field.

In the handleMessage callback, add handlers for game messages:

case 'GAME_STARTED':
  - Update joinState.roomState.gameState.phase to 'rolling' if exists
  - This indicates game has started and server will soon send DICE_ROLLED
  - Auto-send ROLL_DICE message to trigger server roll (first player triggers for all)

case 'DICE_ROLLED':
  - Update myHand in joinState with message.yourHand
  - Update roomState.gameState.phase to 'bidding' if needed

case 'BID_PLACED':
  - Update roomState.gameState.currentBid with message.bid
  - Update roomState.gameState.lastBidderId with message.playerId
  - Find next player and update currentTurnPlayerId (or wait for GAME_STATE)
  - Optionally show toast: "${playerName} bid ${count}x${value}s"

case 'DUDO_CALLED':
  - Show DudoOverlay with type='dudo' via uiStore.setDudoOverlay(true)
  - Store callerId for overlay display

case 'CALZA_CALLED':
  - Show DudoOverlay with type='calza' via uiStore.setDudoOverlay(true)
  - Store callerId for overlay display

case 'ROUND_RESULT':
  - Store message.allHands in uiStore.revealedHands
  - Store result data in uiStore.roundResult
  - Update roomState.gameState.phase to 'reveal'
  - Update player diceCount based on loserId/winnerId

case 'GAME_ENDED':
  - Update roomState.gameState.phase to 'ended'
  - Store winnerId for victory display

case 'GAME_STATE':
  - Full state update - replace roomState.gameState with message.state
  - If message.yourHand provided, update myHand
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>Room page handles all game-related server messages and updates local state appropriately.</done>
</task>

<task type="auto">
  <name>Task 2: Create GameBoard component</name>
  <files>src/components/GameBoard.tsx</files>
  <action>
Create src/components/GameBoard.tsx as a 'use client' component.

Props interface:
```typescript
interface GameBoardProps {
  roomState: ServerRoomState;
  myPlayerId: string;
  myHand: number[];
  sendMessage: (msg: ClientMessage) => void;
}
```

Import from existing components:
- PlayerDiceBadge from './PlayerDiceBadge'
- BidUI from './BidUI'
- SortedDiceDisplay from './SortedDiceDisplay'
- DudoOverlay from './DudoOverlay'
- Dice from './Dice' (for individual dice if needed)

Import from stores:
- useUIStore for showDudoOverlay, revealedHands, roundResult

Layout (per CONTEXT.md - mobile-first):
1. **Player row at top** - horizontal flex of PlayerDiceBadge for each player
   - Show all players including eliminated (dimmed)
   - Highlight current turn player (isActive prop)
   - Show "Thinking..." bubble for current turn player

2. **Center bid area** - prominent display of current bid
   - Use BidUI component
   - Show whose bid it is (lastBidderName, lastBidderColor)
   - Action buttons for current player (Bid, Dudo, Calza)

3. **My dice at bottom** - SortedDiceDisplay with my hand
   - Large, prominent display
   - Show roll animation state via uiStore.isRolling

4. **Overlays** - DudoOverlay when showDudoOverlay is true

Helper computations:
- isMyTurn = gameState.currentTurnPlayerId === myPlayerId
- myPlayer = players.find(p => p.id === myPlayerId)
- myColor = myPlayer?.color ?? 'blue'
- totalDice = activePlayers.reduce((sum, p) => sum + p.diceCount, 0)
- canCalza = !!currentBid && !isMyTurn && myPlayer && !myPlayer.isEliminated
- lastBidder = players.find(p => p.id === lastBidderId)

Action handlers:
- onBid(bid) -> sendMessage({ type: 'PLACE_BID', bid, timestamp: Date.now() })
- onDudo() -> sendMessage({ type: 'CALL_DUDO', timestamp: Date.now() })
- onCalza() -> sendMessage({ type: 'CALL_CALZA', timestamp: Date.now() })

Styling:
- Use existing retro-panel, retro-button classes
- Mobile-first: flex-col layout
- Use Framer Motion for subtle animations
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit</verify>
  <done>GameBoard component renders game state with player row, bid display, my dice, and action buttons.</done>
</task>

<task type="auto">
  <name>Task 3: Wire GameBoard into room page</name>
  <files>src/app/room/[code]/page.tsx</files>
  <action>
Import GameBoard component at top of file:
```typescript
import { GameBoard } from '@/components/GameBoard';
```

In the 'joined' status render section (where RoomLobby is currently rendered):
1. Check if roomState.gameState exists and phase is not 'lobby'
2. If game is active, render GameBoard instead of RoomLobby
3. Pass required props: roomState, myPlayerId (from joinState.playerId), myHand, sendMessage

Conditional render logic:
```typescript
if (joinState.status === 'joined') {
  const gameActive = joinState.roomState.gameState &&
                     joinState.roomState.gameState.phase !== 'lobby';

  if (gameActive) {
    return (
      <GameBoard
        roomState={joinState.roomState}
        myPlayerId={joinState.playerId}
        myHand={joinState.myHand ?? []}
        sendMessage={sendMessage}
      />
    );
  }

  // Existing RoomLobby render
  return (
    <RoomLobby ... />
  );
}
```

Update JoinState type to include myHand:
```typescript
| { status: 'joined'; roomState: ServerRoomState; playerId: string; myHand: number[] }
```

Initialize myHand to empty array when transitioning to joined state.
  </action>
  <verify>
1. npx tsc --noEmit - TypeScript compiles
2. npm run dev - app starts without errors
  </verify>
  <done>Room page conditionally renders GameBoard when game is active, RoomLobby when in lobby.</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - should complete with no errors
2. Start dev server: `npm run dev`
3. Open two browser tabs to same room
4. As host, start game - both players should see GameBoard
5. Current player should see their dice and bid controls
6. Non-current player should see current bid but not controls
</verification>

<success_criteria>
- GameBoard component created and functional
- Game message handlers update local state correctly
- Transition from lobby to game works smoothly
- Players see their own dice after roll
- Current bid displays with bidder info
- Turn indicator shows active player
- Action buttons visible only for current player
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-game-state-sync/06-02-SUMMARY.md`
</output>

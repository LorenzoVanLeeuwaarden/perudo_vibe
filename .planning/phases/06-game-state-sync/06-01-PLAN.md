---
phase: 06-game-state-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - party/index.ts
autonomous: true

must_haves:
  truths:
    - "Server rolls dice for all players when game starts"
    - "Each player receives only their own dice values"
    - "Valid bids update game state and advance turn"
    - "Dudo resolves correctly with all hands revealed"
    - "Calza resolves correctly with winner/loser determined"
    - "Loser loses die, eliminated at 0 dice"
    - "Next round starts after reveal"
  artifacts:
    - path: "party/index.ts"
      provides: "Complete game action handlers"
      exports: ["handleRollDice", "handlePlaceBid", "handleCallDudo", "handleCallCalza", "handleContinueRound"]
  key_links:
    - from: "party/index.ts handleRollDice"
      to: "gameLogic.rollDice"
      via: "import and call"
      pattern: "rollDice\\(player\\.diceCount\\)"
    - from: "party/index.ts handlePlaceBid"
      to: "gameLogic.isValidBid"
      via: "import and call"
      pattern: "isValidBid\\(msg\\.bid"
    - from: "party/index.ts handleCallDudo"
      to: "gameLogic.countMatching"
      via: "import and call"
      pattern: "countMatching\\(player\\.hand"
---

<objective>
Complete all server-side game action handlers in party/index.ts to support real-time game state synchronization.

Purpose: The PartyKit server must handle all game actions (roll, bid, dudo, calza, continue) to maintain authoritative game state. This enables Phase 6 success criteria: players see same public state, hidden dice per player, proper reveal on challenges.

Output: Fully functional game handlers that broadcast appropriate messages to all players while keeping dice hands private.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-game-state-sync/06-RESEARCH.md

# Key source files
@party/index.ts
@src/lib/gameLogic.ts
@src/shared/types.ts
@src/shared/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement handleRollDice and handlePlaceBid</name>
  <files>party/index.ts</files>
  <action>
Import rollDice and isValidBid from '../src/lib/gameLogic' at the top of the file (not from '../src/shared' - gameLogic is not re-exported there).

Implement handleRollDice:
1. Guard: if !this.roomState?.gameState, send GAME_NOT_STARTED error
2. Guard: if phase !== 'rolling', send INVALID_ACTION error
3. For each non-eliminated player in gameState.players, call rollDice(player.diceCount) and assign to player.hand
4. Check for palifico: if roundStarterId player has exactly 1 die and settings.palificoEnabled, set isPalifico = true
5. Transition to 'bidding' phase, set turnStartedAt = Date.now()
6. Call persistState()
7. For each connection in this.room.getConnections():
   - Find matching player in gameState.players by connection.id
   - If found and not eliminated, sendToConnection with DICE_ROLLED { yourHand: player.hand, timestamp }
8. Broadcast GAME_STATE with public state (use getPublicRoomState().gameState) and no yourHand

Implement handlePlaceBid:
1. Guard: if !this.roomState?.gameState or phase !== 'bidding', send INVALID_ACTION
2. Guard: if currentTurnPlayerId !== sender.id, send NOT_YOUR_TURN
3. Guard: if no current bid on first turn of round, any valid bid is allowed; otherwise validate with isValidBid
4. Calculate totalDice = sum of diceCount for non-eliminated players
5. Call isValidBid(msg.bid, gameState.currentBid, totalDice, gameState.isPalifico)
6. If invalid, send INVALID_BID error with reason
7. Update: gameState.currentBid = msg.bid, gameState.lastBidderId = sender.id
8. Advance turn: find current player in activePlayers, get next index (mod length), set currentTurnPlayerId
9. Set turnStartedAt = Date.now()
10. Call persistState()
11. Broadcast BID_PLACED { playerId: sender.id, bid: msg.bid, timestamp }
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>handleRollDice generates dice and sends private hands to each player. handlePlaceBid validates bids and advances turn.</done>
</task>

<task type="auto">
  <name>Task 2: Implement handleCallDudo and handleCallCalza</name>
  <files>party/index.ts</files>
  <action>
Import countMatching from '../src/lib/gameLogic' (should already be imported with rollDice and isValidBid).

Implement handleCallDudo:
1. Guard: if !this.roomState?.gameState or phase !== 'bidding', send INVALID_ACTION
2. Guard: if currentTurnPlayerId !== sender.id, send NOT_YOUR_TURN
3. Guard: if !currentBid, send INVALID_ACTION 'No bid to challenge'
4. Set phase = 'reveal'
5. Broadcast DUDO_CALLED { callerId: sender.id, timestamp }
6. Calculate actualCount: for each non-eliminated player, actualCount += countMatching(player.hand, currentBid.value, isPalifico)
7. Build allHands: Record<string, number[]> mapping playerId -> hand for non-eliminated players
8. Determine loser:
   - If actualCount >= currentBid.count: bid was correct, challenger (sender) loses
   - Else: bid was wrong, lastBidderId loses
9. Decrement loser's diceCount by 1
10. If loser.diceCount <= 0, set loser.isEliminated = true
11. Call persistState()
12. Broadcast ROUND_RESULT { bid: currentBid, actualCount, allHands, loserId, winnerId: null, isCalza: false, timestamp }
13. Check for game end: if only 1 non-eliminated player remains:
    - Set phase = 'ended'
    - Broadcast GAME_ENDED { winnerId: winner.id, timestamp }

Implement handleCallCalza:
1. Guard: if !this.roomState?.gameState or phase !== 'bidding', send INVALID_ACTION
2. Guard: if currentTurnPlayerId === sender.id, send INVALID_ACTION 'Cannot calza on your own turn'
3. Guard: if !currentBid, send INVALID_ACTION 'No bid to calza'
4. Set phase = 'reveal'
5. Broadcast CALZA_CALLED { callerId: sender.id, timestamp }
6. Calculate actualCount (same as dudo)
7. Build allHands (same as dudo)
8. Determine result:
   - If actualCount === currentBid.count (exactly): calza success, caller gains 1 die (max 5)
   - Else: calza failed, caller loses 1 die
9. Apply die change to caller
10. If caller.diceCount <= 0, set caller.isEliminated = true
11. Call persistState()
12. Broadcast ROUND_RESULT { bid: currentBid, actualCount, allHands, loserId (if failed), winnerId (if success), isCalza: true, timestamp }
13. Check for game end (same as dudo)
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>handleCallDudo and handleCallCalza resolve challenges correctly, broadcast results with all hands revealed, handle eliminations.</done>
</task>

<task type="auto">
  <name>Task 3: Implement handleContinueRound</name>
  <files>party/index.ts</files>
  <action>
Implement handleContinueRound:
1. Guard: if !this.roomState?.gameState, send GAME_NOT_STARTED
2. Guard: if phase !== 'reveal', send INVALID_ACTION 'Not in reveal phase'
3. Guard: if phase === 'ended', return early (game is over)
4. Reset for new round:
   - Set currentBid = null
   - Set lastBidderId = null
   - Increment roundNumber
5. Determine next round starter:
   - The loser of the previous round starts the next round
   - Find the player who lost (lowest diceCount change or just use the player who lost a die)
   - If that player is eliminated, move to next non-eliminated player in order
   - Set roundStarterId = newStarter.id
   - Set currentTurnPlayerId = newStarter.id
6. Check palifico: if roundStarterId player has exactly 1 die and settings.palificoEnabled, set isPalifico = true, else false
7. Set phase = 'rolling'
8. Set turnStartedAt = Date.now()
9. Call persistState()
10. Do NOT auto-roll here - let clients trigger ROLL_DICE after seeing phase change
11. Broadcast GAME_STATE with getPublicRoomState().gameState (no yourHand)

Note: The RESEARCH.md suggests auto-rolling on continue. However, for clarity and separation of concerns, broadcast the phase change and let the client (or first player) trigger ROLL_DICE. This keeps the rolling animation visible to all players.
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>handleContinueRound resets game state for next round, correctly determines next round starter, handles palifico detection.</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - should complete with no errors
2. Verify all handlers are implemented (no TODO comments remain in game handlers)
3. Confirm gameLogic imports are correct
</verification>

<success_criteria>
- All 5 game handlers fully implemented (ROLL_DICE, PLACE_BID, CALL_DUDO, CALL_CALZA, CONTINUE_ROUND)
- Private hands only sent via DICE_ROLLED to individual players
- ROUND_RESULT includes allHands for reveal
- Game end detection works (single remaining player wins)
- Palifico detection works (1 die + palificoEnabled)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-game-state-sync/06-01-SUMMARY.md`
</output>

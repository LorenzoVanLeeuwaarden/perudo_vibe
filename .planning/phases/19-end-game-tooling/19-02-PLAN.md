---
phase: 19-end-game-tooling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Single-player shows Victory/Defeat celebration first"
    - "After celebration click, single-player shows stats page with game statistics"
    - "Stats page shows player and all AI opponent statistics"
    - "From stats page, user can return to lobby or quit to mode selection"
    - "Stats track bids placed, dudo/calza calls and successes, dice lost/gained"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "Single-player stats tracking and end game flow"
      contains: "GameResultsScreen"
  key_links:
    - from: "src/app/page.tsx"
      to: "src/components/GameResultsScreen.tsx"
      via: "import and render after celebration"
      pattern: "import.*GameResultsScreen"
    - from: "src/app/page.tsx Victory/Defeat state"
      to: "src/app/page.tsx stats tracking"
      via: "gameStats state object"
      pattern: "gameStats"
---

<objective>
Add statistics tracking and end game flow to single-player mode so it matches multiplayer UX.

Purpose: Single-player currently skips straight from Victory/Defeat celebration to lobby. Users should see their game statistics first, consistent with multiplayer experience.
Output: Single-player tracks stats during gameplay and shows GameResultsScreen after celebration before returning to lobby.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-end-game-tooling/19-RESEARCH.md

Key existing code:
- GameResultsScreen component at src/components/GameResultsScreen.tsx (already works for multiplayer)
- StatCard component at src/components/StatCard.tsx (displays per-player stats)
- PlayerStats and GameStats types defined in src/shared/types.ts

Current single-player flow in page.tsx:
- Victory/Defeat screens call `onPlayAgain` prop
- `onPlayAgain` is bound to `resetGame()` which sets `gameState='Lobby'`
- No stats tracking exists

Multiplayer flow pattern (from RoomPageClient.tsx):
- GAME_ENDED message sets gameStats state
- showCelebration=true, after 8s showResults=true
- GameResultsScreen rendered when showResults && gameStats
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stats tracking state and incrementing logic</name>
  <files>src/app/page.tsx</files>
  <action>
    1. Import GameStats and PlayerStats types from '@/shared/types' (or define inline if simpler)

    2. Add stats tracking state near other game state:
       ```typescript
       // Stats tracking for end game
       const [gameStats, setGameStats] = useState<{
         player: PlayerStats;
         opponents: Record<number, PlayerStats>;  // opponent index -> stats
         roundsPlayed: number;
         totalBids: number;
       } | null>(null);
       ```

       Where PlayerStats is:
       ```typescript
       interface PlayerStats {
         bidsPlaced: number;
         dudosCalled: number;
         dudosSuccessful: number;
         calzasCalled: number;
         calzasSuccessful: number;
         diceLost: number;
         diceGained: number;
       }
       ```

    3. Initialize stats when game starts (in startGame function):
       ```typescript
       const initialStats = {
         player: { bidsPlaced: 0, dudosCalled: 0, dudosSuccessful: 0, calzasCalled: 0, calzasSuccessful: 0, diceLost: 0, diceGained: 0 },
         opponents: {},  // Will be populated as opponents are created
         roundsPlayed: 0,
         totalBids: 0,
       };
       // Populate opponent stats based on opponentCount
       for (let i = 0; i < count; i++) {
         initialStats.opponents[i] = { bidsPlaced: 0, dudosCalled: 0, dudosSuccessful: 0, calzasCalled: 0, calzasSuccessful: 0, diceLost: 0, diceGained: 0 };
       }
       setGameStats(initialStats);
       ```

    4. Track stats on player actions:
       - In handleBid (player bids): increment player.bidsPlaced, totalBids
       - In handleDudo (player calls dudo): increment player.dudosCalled
       - In handleCalza (player calls calza): increment player.calzasCalled

    5. Track stats on AI actions:
       - When AI places bid: increment opponents[oppIdx].bidsPlaced, totalBids
       - When AI calls dudo: increment opponents[oppIdx].dudosCalled
       - When AI calls calza: increment opponents[oppIdx].calzasCalled

    6. Track outcomes in handleReveal (or wherever round results are determined):
       - On dudo success: increment dudosSuccessful for the dudo caller
       - On calza success: increment calzasSuccessful for calza caller, diceGained for calza winner
       - On dice loss: increment diceLost for the loser
       - Increment roundsPlayed

    7. Reset stats in resetGame:
       ```typescript
       setGameStats(null);
       ```
  </action>
  <verify>
    Play a single-player game with some bids, dudo calls, etc.
    Add console.log(gameStats) before Victory/Defeat transition to verify stats are tracked.
  </verify>
  <done>
    Stats state exists, initializes on game start, increments on actions, resets on game reset.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire celebration -> stats -> lobby flow</name>
  <files>src/app/page.tsx</files>
  <action>
    1. Import GameResultsScreen:
       ```typescript
       import { GameResultsScreen } from '@/components/GameResultsScreen';
       ```

    2. Add state for end game flow:
       ```typescript
       const [showStats, setShowStats] = useState(false);
       ```

    3. Create handlers for transitioning through end game:
       ```typescript
       // Called when Victory/Defeat celebration is clicked (onPlayAgain)
       const handleCelebrationComplete = useCallback(() => {
         setShowStats(true);
       }, []);

       // Called from GameResultsScreen "Return to Lobby" button
       const handleReturnToLobby = useCallback(() => {
         setShowStats(false);
         resetGame();
       }, [resetGame]);

       // Called from GameResultsScreen "Leave Game" button
       const handleLeaveGame = useCallback(() => {
         setShowStats(false);
         quitGame();
       }, [quitGame]);
       ```

    4. Convert gameStats to GameStats format for GameResultsScreen:
       ```typescript
       const formattedStats: GameStats | null = gameStats ? {
         roundsPlayed: gameStats.roundsPlayed,
         totalBids: gameStats.totalBids,
         winnerId: gameState === 'Victory' ? 'player' : (opponents.find(o => o.diceCount > 0)?.id.toString() || '0'),
         playerStats: {
           'player': gameStats.player,
           ...Object.fromEntries(
             Object.entries(gameStats.opponents).map(([idx, stats]) => [idx, stats])
           ),
         },
       } : null;
       ```

    5. Build players array for GameResultsScreen:
       ```typescript
       const allPlayers = [
         { id: 'player', name: 'You', color: playerColor },
         ...opponents.map((opp, idx) => ({ id: idx.toString(), name: opp.name, color: opp.color })),
       ];
       ```

    6. Update VictoryScreen/DefeatScreen onPlayAgain to use handleCelebrationComplete instead of resetGame:
       ```typescript
       {gameState === 'Victory' && !showStats && (
         <VictoryScreen playerColor={playerColor} onPlayAgain={handleCelebrationComplete} />
       )}

       {gameState === 'Defeat' && !showStats && (
         <DefeatScreen playerColor={playerColor} onPlayAgain={handleCelebrationComplete} />
       )}
       ```

    7. Add GameResultsScreen after celebration:
       ```typescript
       {/* Stats Screen - shown after Victory/Defeat celebration */}
       {(gameState === 'Victory' || gameState === 'Defeat') && showStats && formattedStats && (
         <GameResultsScreen
           stats={formattedStats}
           players={allPlayers}
           isHost={true}  // Single-player is always "host"
           onReturnToLobby={handleReturnToLobby}
           onLeaveGame={handleLeaveGame}
         />
       )}
       ```

    8. Reset showStats in resetGame:
       ```typescript
       setShowStats(false);
       ```
  </action>
  <verify>
    1. Play a single-player game to Victory or Defeat
    2. Click celebration screen to continue
    3. GameResultsScreen appears showing player + AI stats
    4. "Return to Lobby" button returns to lobby
    5. "Leave Game" button returns to mode selection
  </verify>
  <done>
    Single-player end game flow: Celebration -> Stats Page -> Lobby/Mode Selection
  </done>
</task>

</tasks>

<verification>
Manual verification steps:

1. Start a single-player game with 2 AI opponents
2. Play through the game making bids, calling dudo at least once
3. Win or lose the game
4. Verify Victory/Defeat celebration appears first
5. Click to continue - verify GameResultsScreen appears
6. Verify stats show for player AND AI opponents
7. Verify "Return to Lobby" works
8. Play another game, lose intentionally
9. Verify DefeatScreen -> GameResultsScreen flow works
10. Verify "Leave Game" returns to mode selection

Check stats accuracy:
- Bids placed count matches actual bids made
- Dudo calls and successes tracked correctly
- Dice lost increments when player loses dice
</verification>

<success_criteria>
- [ ] Stats tracking state exists and initializes when game starts
- [ ] Player actions (bid, dudo, calza) increment appropriate stats
- [ ] AI actions increment appropriate opponent stats
- [ ] Round outcomes update diceLost, diceGained, success counts
- [ ] Victory/Defeat screens transition to GameResultsScreen on click
- [ ] GameResultsScreen shows player and all AI opponent statistics
- [ ] "Return to Lobby" resets game and returns to lobby
- [ ] "Leave Game" returns to mode selection
- [ ] Stats reset when starting a new game
</success_criteria>

<output>
After completion, create `.planning/phases/19-end-game-tooling/19-02-SUMMARY.md` following the summary template.
</output>

---
phase: 20-core-gauntlet-loop-transitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/gauntletStore.ts
  - src/stores/index.ts
  - src/components/ModeSelection.tsx
  - src/components/gauntlet/RulesScreen.tsx
  - src/components/gauntlet/index.ts
autonomous: true

must_haves:
  truths:
    - "Player can select 'Gauntlet' from main menu"
    - "Player sees rules reminder before entering gauntlet"
    - "Gauntlet state store manages persistent dice count and streak"
  artifacts:
    - path: "src/stores/gauntletStore.ts"
      provides: "Gauntlet state management"
      exports: ["useGauntletStore"]
    - path: "src/components/ModeSelection.tsx"
      provides: "Gauntlet mode button in menu"
      contains: "Gauntlet"
    - path: "src/components/gauntlet/RulesScreen.tsx"
      provides: "Rules reminder with Enter CTA"
      exports: ["RulesScreen"]
  key_links:
    - from: "src/components/ModeSelection.tsx"
      to: "onSelectGauntlet callback"
      via: "button onClick"
      pattern: "onSelectGauntlet"
    - from: "src/components/gauntlet/RulesScreen.tsx"
      to: "useGauntletStore"
      via: "store action"
      pattern: "startGauntlet"
---

<objective>
Create Gauntlet mode foundation: state store and mode entry flow.

Purpose: Enable player to select Gauntlet mode from main menu and see rules reminder before starting. Establishes the state management that persists player dice count and streak across duels.

Output: Zustand gauntlet store, updated ModeSelection with Gauntlet button, RulesScreen component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

Phase context:
@.planning/phases/20-core-gauntlet-loop-transitions/20-CONTEXT.md
@.planning/phases/20-core-gauntlet-loop-transitions/20-RESEARCH.md

Existing patterns:
@src/stores/gameStore.ts
@src/components/ModeSelection.tsx
@src/lib/ai/personalities.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gauntletStore.ts</name>
  <files>src/stores/gauntletStore.ts, src/stores/index.ts</files>
  <action>
Create a Zustand store for gauntlet-specific state in `src/stores/gauntletStore.ts`.

Follow the pattern from `gameStore.ts`:
- Use `create` from zustand
- Define interface `GauntletState` with:
  - `playerDiceCount: number` (starts at 5, persists across duels)
  - `streak: number` (opponents defeated in current run)
  - `currentRound: number` (which duel number)
  - `currentOpponentName: string | null` (AI name for current duel)
  - `currentPersonalityId: string | null` (turtle, calculator, shark)
  - `isActive: boolean` (gauntlet in progress)
  - `screen: 'rules' | 'fightCard' | 'gameplay' | 'victory' | 'gameOver'` (current screen state)

- Define actions:
  - `startGauntlet()` - Reset to initial state (5 dice, streak 0, round 1), set isActive true, screen to 'fightCard', select first opponent
  - `winDuel()` - Increment streak and round, keep playerDiceCount as-is (from gameplay), set screen to 'victory'
  - `loseDie()` - Decrement playerDiceCount by 1, if playerDiceCount becomes 0 then set screen to 'gameOver'
  - `setPlayerDiceCount(count: number)` - Direct setter for syncing from gameplay
  - `showFightCard()` - Set screen to 'fightCard', select next opponent based on round
  - `startDuel()` - Set screen to 'gameplay'
  - `restartGauntlet()` - Calls startGauntlet()
  - `exitToMenu()` - Reset all state and set isActive false
  - `selectOpponentForRound()` - Returns personality based on round: 1-3 = turtle, 4-6 = calculator, 7+ = shark. Picks random AI name from AI_NAMES (import from personalities or define locally)

- Derived getter:
  - `getDifficultyTier()` - Returns 'Easy' for rounds 1-3, 'Medium' for 4-6, 'Hard' for 7+

Export `useGauntletStore`.

Update `src/stores/index.ts` to re-export useGauntletStore.
  </action>
  <verify>TypeScript compiles with no errors: `npx tsc --noEmit`</verify>
  <done>gauntletStore.ts exports useGauntletStore with all state and actions defined</done>
</task>

<task type="auto">
  <name>Task 2: Add Gauntlet mode to ModeSelection</name>
  <files>src/components/ModeSelection.tsx</files>
  <action>
Update ModeSelection component to add a third mode option for Gauntlet.

1. Add `onSelectGauntlet: () => void` to ModeSelectionProps interface

2. Add new state value to GameMode type: `type GameMode = 'ai' | 'multiplayer' | 'gauntlet' | null`

3. Add `handleSelectGauntlet` callback following the pattern of handleSelectAI:
   - Check if selectedMode !== null (prevent double-click)
   - Set selectedMode to 'gauntlet'
   - setTimeout to call onSelectGauntlet after 500ms

4. Add third button after "Play with Friends" button:
   - Use same structure as existing buttons (motion.button with retro-panel styling)
   - Icon: Use `Swords` from lucide-react (import it)
   - Title: "The Gauntlet"
   - Subtitle: "Endless 1v1 survival"
   - Same animation pattern: fade out other buttons when gauntlet selected
   - Apply selectedMode logic for opacity/scale animations

5. Ensure button opacity animations work correctly:
   - When 'gauntlet' selected: other two buttons fade out
   - When 'ai' or 'multiplayer' selected: gauntlet button fades out

Visual weight should be equal to other options (same size, same styling) per CONTEXT.md decision.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. Visually verify three buttons appear equal in dev mode.</verify>
  <done>ModeSelection renders three equal-weight mode buttons including Gauntlet option</done>
</task>

<task type="auto">
  <name>Task 3: Create RulesScreen component</name>
  <files>src/components/gauntlet/RulesScreen.tsx, src/components/gauntlet/index.ts</files>
  <action>
Create `src/components/gauntlet/` directory and RulesScreen component.

`src/components/gauntlet/RulesScreen.tsx`:

Props interface:
- `onEnter: () => void` - Called when player clicks "Enter the Gauntlet"
- `playerColor: PlayerColor` - For theming consistency

Component renders a full-screen overlay (following VictoryScreen/DefeatScreen pattern):
- Dark, ominous background (radial gradient from dark purple to black)
- Centered content with motion animations

Content (from CONTEXT.md):
1. Title: "THE GAUNTLET" - large, intimidating text with glow effect
2. Rules section with 3 bullet points:
   - "Your dice carry over between duels - no healing"
   - "Each opponent starts fresh with 5 dice"
   - "Difficulty escalates: Turtle -> Calculator -> Shark"
3. "Enter the Gauntlet" button:
   - Dramatic styling: bold red/orange gradient background
   - Use player color for accent glow
   - Intimidating/challenging CTA tone (large, prominent)
   - whileHover and whileTap animations
   - Calls onEnter on click

Use Framer Motion for entry animations:
- Title slides down with opacity fade
- Rules fade in with stagger delay
- Button scales up from 0

Follow existing patterns from VictoryScreen:
- useIsFirefox and useReducedMotion hooks for simplified animations
- motion.div for animated container

Create `src/components/gauntlet/index.ts` that exports RulesScreen.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>RulesScreen component exists with rules reminder and "Enter the Gauntlet" button</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. Gauntlet store can be imported: `import { useGauntletStore } from '@/stores'`
3. ModeSelection accepts onSelectGauntlet prop
4. RulesScreen renders and exports correctly
</verification>

<success_criteria>
- GAUN-01 partially complete: Gauntlet mode selection exists in menu (full completion requires wiring in Plan 03)
- gauntletStore manages playerDiceCount, streak, currentRound, screen state
- RulesScreen displays gauntlet rules with dramatic Enter CTA
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-core-gauntlet-loop-transitions/20-01-SUMMARY.md`
</output>

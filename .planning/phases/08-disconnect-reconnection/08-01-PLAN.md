---
phase: 08-disconnect-reconnection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/types.ts
  - party/index.ts
autonomous: true

must_haves:
  truths:
    - "Disconnected player's position is maintained for 60 seconds"
    - "AI plays for disconnected player when their turn comes"
    - "Reconnecting player resumes with their state intact"
    - "Turn timer and disconnect grace period coexist"
  artifacts:
    - path: "src/shared/types.ts"
      provides: "disconnectedAt timestamp field on ServerPlayer"
      contains: "disconnectedAt"
    - path: "party/index.ts"
      provides: "Unified alarm handler, disconnect scheduling, AI takeover"
      exports: ["onAlarm", "onClose", "onConnect"]
  key_links:
    - from: "party/index.ts onClose"
      to: "storage.put disconnect_{playerId}"
      via: "schedules elimination alarm"
      pattern: "disconnect_.*eliminateAt"
    - from: "party/index.ts onAlarm"
      to: "storage.get disconnect_*"
      via: "checks pending disconnects"
      pattern: "disconnect_"
    - from: "party/index.ts onConnect"
      to: "storage.delete disconnect_{playerId}"
      via: "clears scheduled elimination"
      pattern: "delete.*disconnect_"
---

<objective>
Implement server-side disconnect handling with grace period and AI takeover

Purpose: Players who disconnect during a game should have 60 seconds to reconnect before being eliminated. During their turn, AI plays on their behalf (using the existing conservative timeout AI).

Output: Server handles disconnects gracefully, schedules elimination after grace period, AI takes over when disconnected player's turn comes, reconnection restores full state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-disconnect-reconnection/08-CONTEXT.md
@.planning/phases/08-disconnect-reconnection/08-RESEARCH.md
@party/index.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disconnectedAt field to ServerPlayer type</name>
  <files>src/shared/types.ts</files>
  <action>
Add `disconnectedAt: number | null` field to the ServerPlayer interface.

This timestamp tracks when the player disconnected:
- `null` when connected
- Unix timestamp when disconnect detected

This field is used by both server (for grace period timing) and client (for delayed visual display).

Location: Add after `isConnected: boolean` in the ServerPlayer interface.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors.</verify>
  <done>ServerPlayer interface includes disconnectedAt field with proper type.</done>
</task>

<task type="auto">
  <name>Task 2: Implement unified alarm handler for turn timer and disconnect</name>
  <files>party/index.ts</files>
  <action>
PartyKit only supports ONE alarm per room. Refactor the alarm system to handle both turn timers and disconnect grace periods using a storage-based approach.

**Storage Schema:**
```typescript
// Turn timer (existing pattern)
storage.put('turnTimer', { fireAt: timestamp })

// Disconnect elimination (per player)
storage.put(`disconnect_${playerId}`, { playerId, eliminateAt: timestamp })
```

**Refactored setAlarm approach:**

1. Create helper `scheduleNextAlarm()` that:
   - Reads all pending deadlines (turn timer + all disconnect_* entries)
   - Sets alarm for the NEAREST deadline
   - If no pending deadlines, clears alarm

2. Modify `onAlarm()` to:
   - Check turn timer: if in bidding phase and turnTimer.fireAt <= now, execute timeout AI (existing logic)
   - Check disconnect_* entries: for each where eliminateAt <= now:
     - If player is still disconnected (no reconnection), eliminate them
     - Delete the storage entry
   - Call `scheduleNextAlarm()` to set next alarm if more pending

3. Modify `setTurnTimer()` to:
   - Store turn timer in storage.put('turnTimer', { fireAt })
   - Call `scheduleNextAlarm()`

**Elimination logic (when grace period expires):**
- Find player by ID
- If player.isConnected is false (still disconnected):
  - Set player.isEliminated = true
  - Set player.diceCount = 0
  - Broadcast PLAYER_LEFT with reason 'eliminated' (new reason type)
  - Check for game end condition
- Delete the disconnect_* storage entry
- Persist state

**Important:** The existing onAlarm logic for timeout AI should remain intact - just integrate it into the unified handler.
  </action>
  <verify>
Run `npx tsc --noEmit` - compiles without errors.
Review that onAlarm handles both turn timeout and disconnect elimination.
  </verify>
  <done>Unified alarm handler processes both turn timers and disconnect grace periods. Storage-based approach allows multiple pending deadlines with single PartyKit alarm.</done>
</task>

<task type="auto">
  <name>Task 3: Schedule disconnect elimination and handle AI takeover on turn</name>
  <files>party/index.ts</files>
  <action>
**In onClose handler (when player disconnects):**

After setting `player.isConnected = false`:

1. Set `player.disconnectedAt = Date.now()`

2. If game is in progress (phase !== 'lobby' AND phase !== 'ended'):
   - Store disconnect elimination: `storage.put(`disconnect_${connection.id}`, { playerId: connection.id, eliminateAt: Date.now() + 60000 })`
   - Call `scheduleNextAlarm()` to potentially update alarm

3. If it's the disconnected player's turn (currentTurnPlayerId === connection.id):
   - AI should take over immediately (same behavior as timeout)
   - Call the existing timeout AI logic to make a move
   - This prevents the game from stalling

**In onConnect handler (when player reconnects):**

After setting `player.isConnected = true`:

1. Set `player.disconnectedAt = null`

2. Delete scheduled elimination: `storage.delete(`disconnect_${connection.id}`)`

3. Call `scheduleNextAlarm()` to recalculate next alarm

4. If reconnecting player is the same as the one who receives ROOM_STATE:
   - Send toast trigger message: Add a new server message type or use existing PLAYER_RECONNECTED for self
   - The client will show "Welcome back!" toast when receiving this message for themselves

**Handle turn during disconnect:**

When a player disconnects during the bidding phase and it's their turn:
- The setTurnTimer is already active
- When turn timer fires (in onAlarm), check if player.isConnected is false
- If disconnected, current timeout AI logic already handles it
- Mark lastActionWasTimeout = true for UI badge

This reuses the existing conservative AI strategy (80% probability threshold for dudo, never calza).
  </action>
  <verify>
Run `npx tsc --noEmit` - compiles without errors.
Test scenarios mentally:
1. Player disconnects mid-game (not their turn) -> should schedule 60s elimination
2. Player disconnects on their turn -> timeout AI acts immediately
3. Player reconnects within 60s -> elimination cancelled
4. Player fails to reconnect -> eliminated after 60s
  </verify>
  <done>
onClose schedules 60-second elimination and sets disconnectedAt.
onConnect clears elimination and resets disconnectedAt.
AI takes over disconnected player's turn using existing timeout logic.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Server starts: `npm run dev` runs without errors
3. Code review: onAlarm handles both turn timer and disconnect
4. Code review: onClose schedules elimination for mid-game disconnects
5. Code review: onConnect clears scheduled elimination
</verification>

<success_criteria>
- ServerPlayer has disconnectedAt field
- Unified alarm handler processes turn timers and disconnect grace periods
- Disconnect schedules 60-second elimination (only during active game)
- Reconnection within grace period cancels elimination
- AI plays for disconnected player when their turn comes (reuses existing timeout AI)
- Game detects win condition after elimination
</success_criteria>

<output>
After completion, create `.planning/phases/08-disconnect-reconnection/08-01-SUMMARY.md`
</output>

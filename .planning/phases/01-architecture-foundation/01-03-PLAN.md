---
phase: 01-architecture-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/stores/gameStore.ts
  - src/stores/uiStore.ts
  - src/stores/index.ts
  - party/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "useGameStore hook exists with server-synced state"
    - "useUIStore hook exists with client-only state"
    - "Game store separates server state from local state"
    - "UI store includes animation state, local preferences, connection status"
    - "PartyKit server implements Party.Server interface"
    - "PartyKit server has message handler with Zod validation"
    - "Server state is distinct from client state (no mixing)"
  artifacts:
    - path: "src/stores/gameStore.ts"
      provides: "Server-synced game state Zustand store"
      exports: ["useGameStore"]
      min_lines: 40
    - path: "src/stores/uiStore.ts"
      provides: "Client-only UI state Zustand store"
      exports: ["useUIStore"]
      min_lines: 30
    - path: "src/stores/index.ts"
      provides: "Barrel export for stores"
      min_lines: 3
    - path: "party/index.ts"
      provides: "PartyKit server implementation skeleton"
      exports: ["default"]
      min_lines: 50
  key_links:
    - from: "src/stores/gameStore.ts"
      to: "src/shared/types.ts"
      via: "import"
      pattern: "import.*from.*['\"]@/shared"
    - from: "party/index.ts"
      to: "src/shared/messages.ts"
      via: "import"
      pattern: "import.*from.*['\"]../src/shared"
---

<objective>
Create Zustand stores for client-side state management and PartyKit server skeleton with proper message handling.

Purpose: Complete the architecture foundation by implementing the client-side state separation (game store vs UI store) and the server-side message handling infrastructure. This provides the scaffolding that all multiplayer features will build upon.

Output: Two Zustand stores (gameStore for server-synced state, uiStore for client-only state); PartyKit server with onConnect, onMessage, onClose handlers and Zod message validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-architecture-foundation/01-CONTEXT.md
@.planning/phases/01-architecture-foundation/01-RESEARCH.md
@src/shared/types.ts
@src/shared/messages.ts
@src/shared/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand stores with state separation</name>
  <files>src/stores/gameStore.ts, src/stores/uiStore.ts, src/stores/index.ts</files>
  <action>
    Create `src/stores/gameStore.ts` - server-synced state:
    ```typescript
    import { create } from 'zustand';
    import type { ServerRoomState, ServerGameState, PublicPlayerState, Bid } from '@/shared/types';

    interface GameStore {
      // Server-synced state (received from PartyKit)
      roomState: ServerRoomState | null;
      myPlayerId: string | null;
      myHand: number[];  // My dice values (private, only I receive this)

      // Actions - called from WebSocket message handlers
      setRoomState: (state: ServerRoomState) => void;
      setMyPlayerId: (id: string) => void;
      setMyHand: (hand: number[]) => void;
      updateGameState: (state: ServerGameState) => void;
      addPlayer: (player: PublicPlayerState) => void;
      removePlayer: (playerId: string) => void;
      updatePlayerConnection: (playerId: string, isConnected: boolean) => void;
      reset: () => void;

      // Derived getters
      isMyTurn: () => boolean;
      currentPlayer: () => PublicPlayerState | null;
      isHost: () => boolean;
      canStartGame: () => boolean;
      activePlayers: () => PublicPlayerState[];
    }

    export const useGameStore = create<GameStore>((set, get) => ({
      roomState: null,
      myPlayerId: null,
      myHand: [],

      setRoomState: (state) => set({ roomState: state }),
      setMyPlayerId: (id) => set({ myPlayerId: id }),
      setMyHand: (hand) => set({ myHand: hand }),

      updateGameState: (state) => set((prev) => ({
        roomState: prev.roomState ? { ...prev.roomState, gameState: state } : null,
      })),

      addPlayer: (player) => set((prev) => {
        if (!prev.roomState) return prev;
        return {
          roomState: {
            ...prev.roomState,
            players: [...prev.roomState.players, player as any],
          },
        };
      }),

      removePlayer: (playerId) => set((prev) => {
        if (!prev.roomState) return prev;
        return {
          roomState: {
            ...prev.roomState,
            players: prev.roomState.players.filter(p => p.id !== playerId),
          },
        };
      }),

      updatePlayerConnection: (playerId, isConnected) => set((prev) => {
        if (!prev.roomState) return prev;
        return {
          roomState: {
            ...prev.roomState,
            players: prev.roomState.players.map(p =>
              p.id === playerId ? { ...p, isConnected } : p
            ),
          },
        };
      }),

      reset: () => set({
        roomState: null,
        myPlayerId: null,
        myHand: [],
      }),

      // Derived getters
      isMyTurn: () => {
        const { roomState, myPlayerId } = get();
        return roomState?.gameState?.currentTurnPlayerId === myPlayerId;
      },

      currentPlayer: () => {
        const { roomState } = get();
        if (!roomState?.gameState?.currentTurnPlayerId) return null;
        return roomState.players.find(
          p => p.id === roomState.gameState!.currentTurnPlayerId
        ) ?? null;
      },

      isHost: () => {
        const { roomState, myPlayerId } = get();
        return roomState?.hostId === myPlayerId;
      },

      canStartGame: () => {
        const { roomState } = get();
        if (!roomState) return false;
        const activePlayers = roomState.players.filter(p => p.isConnected && !p.isEliminated);
        return activePlayers.length >= 2 && activePlayers.length <= 6;
      },

      activePlayers: () => {
        const { roomState } = get();
        if (!roomState) return [];
        return roomState.players.filter(p => p.isConnected && !p.isEliminated);
      },
    }));
    ```

    Create `src/stores/uiStore.ts` - client-only state:
    ```typescript
    import { create } from 'zustand';
    import { persist } from 'zustand/middleware';
    import type { PlayerColor } from '@/shared/types';

    interface UIStore {
      // Animation state (not persisted)
      isRolling: boolean;
      showDudoOverlay: boolean;
      revealProgress: number;
      dyingDieOwner: string | null;
      dyingDieIndex: number;
      highlightedDiceIndex: number;
      countingComplete: boolean;

      // Connection state (not persisted)
      connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
      connectionError: string | null;

      // Local preferences (persisted)
      soundEnabled: boolean;
      playerColor: PlayerColor;
      playerName: string;

      // Actions
      setRolling: (isRolling: boolean) => void;
      setDudoOverlay: (show: boolean) => void;
      setRevealProgress: (progress: number) => void;
      setDyingDie: (owner: string | null, index: number) => void;
      setHighlightedDice: (index: number) => void;
      setCountingComplete: (complete: boolean) => void;
      setConnectionStatus: (status: UIStore['connectionStatus'], error?: string) => void;
      setSoundEnabled: (enabled: boolean) => void;
      setPlayerColor: (color: PlayerColor) => void;
      setPlayerName: (name: string) => void;
      resetAnimationState: () => void;
    }

    // Split into persisted and non-persisted state
    export const useUIStore = create<UIStore>()(
      persist(
        (set) => ({
          // Animation state - not persisted
          isRolling: false,
          showDudoOverlay: false,
          revealProgress: 0,
          dyingDieOwner: null,
          dyingDieIndex: -1,
          highlightedDiceIndex: -1,
          countingComplete: false,

          // Connection state - not persisted
          connectionStatus: 'disconnected',
          connectionError: null,

          // Local preferences - persisted
          soundEnabled: true,
          playerColor: 'blue',
          playerName: '',

          // Actions
          setRolling: (isRolling) => set({ isRolling }),
          setDudoOverlay: (show) => set({ showDudoOverlay: show }),
          setRevealProgress: (progress) => set({ revealProgress: progress }),
          setDyingDie: (owner, index) => set({ dyingDieOwner: owner, dyingDieIndex: index }),
          setHighlightedDice: (index) => set({ highlightedDiceIndex: index }),
          setCountingComplete: (complete) => set({ countingComplete: complete }),
          setConnectionStatus: (status, error) => set({
            connectionStatus: status,
            connectionError: error ?? null,
          }),
          setSoundEnabled: (enabled) => set({ soundEnabled: enabled }),
          setPlayerColor: (color) => set({ playerColor: color }),
          setPlayerName: (name) => set({ playerName: name }),
          resetAnimationState: () => set({
            isRolling: false,
            showDudoOverlay: false,
            revealProgress: 0,
            dyingDieOwner: null,
            dyingDieIndex: -1,
            highlightedDiceIndex: -1,
            countingComplete: false,
          }),
        }),
        {
          name: 'perudo-ui-preferences',
          // Only persist preferences, not animation/connection state
          partialize: (state) => ({
            soundEnabled: state.soundEnabled,
            playerColor: state.playerColor,
            playerName: state.playerName,
          }),
        }
      )
    );
    ```

    Create `src/stores/index.ts`:
    ```typescript
    export { useGameStore } from './gameStore';
    export { useUIStore } from './uiStore';
    ```

    Important: The stores explicitly separate:
    - gameStore: Server-authoritative state received via WebSocket
    - uiStore: Client-only animation state + persisted preferences

    This separation prevents mixing network-synced state with local UI state (per RESEARCH.md anti-patterns).
  </action>
  <verify>
    Run `npx tsc --noEmit src/stores/*.ts` - should compile without errors.
    Run `grep "create<" src/stores/*.ts` - should show two Zustand stores.
    Run `grep "persist" src/stores/uiStore.ts` - should show persistence middleware.
  </verify>
  <done>
    - src/stores/gameStore.ts exports useGameStore with server-synced state
    - src/stores/uiStore.ts exports useUIStore with animation state and persisted preferences
    - State separation clear: gameStore for network state, uiStore for local state
    - src/stores/index.ts exports both hooks
    - All TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PartyKit server skeleton with message handling</name>
  <files>party/index.ts</files>
  <action>
    Create `party/index.ts` - PartyKit server implementation:
    ```typescript
    import type * as Party from 'partykit/server';
    import {
      ClientMessageSchema,
      type ClientMessage,
      type ServerMessage,
      type ServerRoomState,
      type ServerPlayer,
      type GameSettings,
      STARTING_DICE,
      MAX_PLAYERS,
      DEFAULT_TURN_TIMEOUT_MS,
    } from '../src/shared';

    // Default game settings
    const DEFAULT_SETTINGS: GameSettings = {
      startingDice: STARTING_DICE,
      palificoEnabled: false,
      turnTimeoutMs: DEFAULT_TURN_TIMEOUT_MS,
    };

    export default class GameServer implements Party.Server {
      // Room state - persisted via PartyKit storage
      private roomState: ServerRoomState | null = null;

      constructor(readonly room: Party.Room) {}

      // Called when room starts or wakes from hibernation
      async onStart(): Promise<void> {
        // Load persisted state if it exists
        const savedState = await this.room.storage.get<ServerRoomState>('roomState');
        if (savedState) {
          this.roomState = savedState;
        }
      }

      // Called when a client connects
      async onConnect(
        connection: Party.Connection,
        ctx: Party.ConnectionContext
      ): Promise<void> {
        // Store connection metadata
        connection.setState({ connectedAt: Date.now() });

        // If room doesn't exist yet, don't send state
        // Client must send JOIN_ROOM message to initialize
        if (this.roomState) {
          // Check if this is a reconnecting player
          const existingPlayer = this.roomState.players.find(
            p => p.id === connection.id
          );
          if (existingPlayer) {
            // Reconnection - update connection status
            existingPlayer.isConnected = true;
            await this.persistState();

            // Send current state to reconnecting player
            this.sendToConnection(connection, {
              type: 'ROOM_STATE',
              state: this.getPublicRoomState(),
              yourPlayerId: connection.id,
              yourHand: existingPlayer.hand,
              timestamp: Date.now(),
            });
          }
        }
      }

      // Called when a message is received
      async onMessage(
        message: string | ArrayBuffer,
        sender: Party.Connection
      ): Promise<void> {
        if (typeof message !== 'string') {
          this.sendError(sender, 'INVALID_ACTION', 'Binary messages not supported');
          return;
        }

        // Parse and validate message with Zod
        let parsed: ClientMessage;
        try {
          const raw = JSON.parse(message);
          parsed = ClientMessageSchema.parse(raw);
        } catch (error) {
          this.sendError(sender, 'INVALID_ACTION', 'Invalid message format');
          return;
        }

        // Handle message by type - TypeScript narrows automatically
        switch (parsed.type) {
          case 'JOIN_ROOM':
            await this.handleJoinRoom(parsed, sender);
            break;
          case 'LEAVE_ROOM':
            await this.handleLeaveRoom(parsed, sender);
            break;
          case 'START_GAME':
            await this.handleStartGame(parsed, sender);
            break;
          case 'ROLL_DICE':
            await this.handleRollDice(parsed, sender);
            break;
          case 'PLACE_BID':
            await this.handlePlaceBid(parsed, sender);
            break;
          case 'CALL_DUDO':
            await this.handleCallDudo(parsed, sender);
            break;
          case 'CALL_CALZA':
            await this.handleCallCalza(parsed, sender);
            break;
          case 'CONTINUE_ROUND':
            await this.handleContinueRound(parsed, sender);
            break;
          case 'UPDATE_SETTINGS':
            await this.handleUpdateSettings(parsed, sender);
            break;
          case 'KICK_PLAYER':
            await this.handleKickPlayer(parsed, sender);
            break;
        }
      }

      // Called when a client disconnects
      async onClose(connection: Party.Connection): Promise<void> {
        if (!this.roomState) return;

        const player = this.roomState.players.find(p => p.id === connection.id);
        if (player) {
          player.isConnected = false;
          await this.persistState();

          // Notify other players
          this.broadcast({
            type: 'PLAYER_LEFT',
            playerId: connection.id,
            reason: 'disconnected',
            timestamp: Date.now(),
          }, [connection.id]);
        }
      }

      // ========== Message Handlers (Stubs) ==========
      // These will be fully implemented in later phases

      private async handleJoinRoom(
        msg: Extract<ClientMessage, { type: 'JOIN_ROOM' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 4 (Join Flow)
        // For now, just log
        console.log(`[JOIN_ROOM] ${msg.playerName} wants to join`);
      }

      private async handleLeaveRoom(
        msg: Extract<ClientMessage, { type: 'LEAVE_ROOM' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 4
        console.log(`[LEAVE_ROOM] ${sender.id} leaving`);
      }

      private async handleStartGame(
        msg: Extract<ClientMessage, { type: 'START_GAME' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 5 (Lobby Experience)
        console.log(`[START_GAME] requested by ${sender.id}`);
      }

      private async handleRollDice(
        msg: Extract<ClientMessage, { type: 'ROLL_DICE' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 6 (Game State Sync)
        console.log(`[ROLL_DICE] requested by ${sender.id}`);
      }

      private async handlePlaceBid(
        msg: Extract<ClientMessage, { type: 'PLACE_BID' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 6
        console.log(`[PLACE_BID] ${msg.bid.count}x${msg.bid.value} by ${sender.id}`);
      }

      private async handleCallDudo(
        msg: Extract<ClientMessage, { type: 'CALL_DUDO' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 6
        console.log(`[CALL_DUDO] by ${sender.id}`);
      }

      private async handleCallCalza(
        msg: Extract<ClientMessage, { type: 'CALL_CALZA' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 6
        console.log(`[CALL_CALZA] by ${sender.id}`);
      }

      private async handleContinueRound(
        msg: Extract<ClientMessage, { type: 'CONTINUE_ROUND' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 6
        console.log(`[CONTINUE_ROUND] by ${sender.id}`);
      }

      private async handleUpdateSettings(
        msg: Extract<ClientMessage, { type: 'UPDATE_SETTINGS' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 5
        console.log(`[UPDATE_SETTINGS] by ${sender.id}`);
      }

      private async handleKickPlayer(
        msg: Extract<ClientMessage, { type: 'KICK_PLAYER' }>,
        sender: Party.Connection
      ): Promise<void> {
        // TODO: Implement in Phase 5
        console.log(`[KICK_PLAYER] ${msg.playerId} by ${sender.id}`);
      }

      // ========== Helper Methods ==========

      private getPublicRoomState(): ServerRoomState {
        if (!this.roomState) {
          throw new Error('Room state not initialized');
        }
        // Return state without private hand data
        return {
          ...this.roomState,
          players: this.roomState.players.map(p => ({
            ...p,
            hand: [], // Never send other players' hands
          })),
        };
      }

      private async persistState(): Promise<void> {
        if (this.roomState) {
          await this.room.storage.put('roomState', this.roomState);
        }
      }

      private sendToConnection(
        connection: Party.Connection,
        message: ServerMessage
      ): void {
        connection.send(JSON.stringify(message));
      }

      private broadcast(
        message: ServerMessage,
        exclude?: string[]
      ): void {
        const json = JSON.stringify(message);
        for (const connection of this.room.getConnections()) {
          if (!exclude?.includes(connection.id)) {
            connection.send(json);
          }
        }
      }

      private sendError(
        connection: Party.Connection,
        type: string,
        reason: string
      ): void {
        this.sendToConnection(connection, {
          type: 'ERROR',
          error: { type: type as any, reason },
          timestamp: Date.now(),
        });
      }
    }
    ```

    Key implementation notes:
    - Uses class syntax with `Party.Server` interface (not legacy `PartyKitServer`)
    - Zod validation on all incoming messages
    - Switch statement with TypeScript type narrowing
    - Handler stubs for each message type (to be implemented in future phases)
    - Helper methods for state persistence, broadcasting, error handling
    - Private hand data never sent in broadcast (security: prevents cheating)
  </action>
  <verify>
    Run `npx tsc --noEmit party/index.ts` - should compile without errors.
    Run `grep "implements Party.Server" party/index.ts` - should find the class declaration.
    Run `grep "ClientMessageSchema.parse" party/index.ts` - should find Zod validation.
    Run `npx partykit dev --dry-run` - should validate partykit.json config (may show warning about no handler, that's OK).
  </verify>
  <done>
    - party/index.ts exports GameServer class implementing Party.Server
    - onStart, onConnect, onMessage, onClose handlers implemented
    - Zod validation on incoming messages
    - Handler stubs for all 10 client message types
    - Helper methods for broadcast, sendToConnection, sendError, persistState
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit src/stores/*.ts party/index.ts` - all files compile
2. `grep "useGameStore\|useUIStore" src/stores/*.ts` - both hooks exported
3. `grep "implements Party.Server" party/index.ts` - server class found
4. `grep "ClientMessageSchema.parse" party/index.ts` - Zod validation in place
5. `npm run build` - Next.js build still works (stores are client components)
</verification>

<success_criteria>
- useGameStore provides server-synced state (roomState, myPlayerId, myHand)
- useUIStore provides client-only state (animation, preferences, connection)
- State separation clear and enforced (no mixing)
- Preferences persisted to localStorage via Zustand persist middleware
- PartyKit server validates all messages with Zod
- Server has handler stubs for all message types
- Server never broadcasts private hand data
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-architecture-foundation/01-03-SUMMARY.md`
</output>

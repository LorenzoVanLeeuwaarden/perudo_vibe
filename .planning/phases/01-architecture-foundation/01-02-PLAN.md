---
phase: 01-architecture-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/shared/types.ts
  - src/shared/messages.ts
  - src/shared/constants.ts
  - src/shared/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ServerGameState type exists with phase, players, currentBid, turn tracking"
    - "ServerPlayer type exists with id, name, color, diceCount, hand, connection status"
    - "ServerRoomState type exists with roomCode, hostId, players, settings"
    - "ClientMessage Zod schema covers JOIN_ROOM, PLACE_BID, CALL_DUDO, CALL_CALZA, START_GAME"
    - "ServerMessage Zod schema covers ROOM_STATE, GAME_STATE, ERROR, PLAYER_JOINED, PLAYER_LEFT"
    - "All messages include timestamp field"
    - "Error types are structured objects with type and reason"
  artifacts:
    - path: "src/shared/types.ts"
      provides: "Server-authoritative state types"
      exports: ["ServerGameState", "ServerPlayer", "ServerRoomState", "GameSettings"]
      min_lines: 50
    - path: "src/shared/messages.ts"
      provides: "Zod schemas for client-server messages"
      exports: ["ClientMessageSchema", "ServerMessageSchema", "ClientMessage", "ServerMessage"]
      min_lines: 80
    - path: "src/shared/constants.ts"
      provides: "Shared constants"
      exports: ["ROOM_CODE_LENGTH", "MAX_PLAYERS", "MIN_PLAYERS"]
      min_lines: 10
    - path: "src/shared/index.ts"
      provides: "Barrel export for shared module"
      min_lines: 5
  key_links:
    - from: "src/shared/messages.ts"
      to: "src/shared/types.ts"
      via: "import"
      pattern: "import.*from.*['\"]\\./types['\"]"
---

<objective>
Define the server-authoritative types and Zod message protocol that form the contract between PartyKit server and Next.js client.

Purpose: This is the "schema first" approach - define the data shapes before writing any networking code. These types and schemas will be imported by both server (party/index.ts) and client (Zustand stores, hooks) to ensure type safety across the WebSocket boundary.

Output: Complete type definitions for game state, player state, room state; Zod schemas for all client-to-server and server-to-client messages; shared constants.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-architecture-foundation/01-CONTEXT.md
@.planning/phases/01-architecture-foundation/01-RESEARCH.md
@src/lib/types.ts
@src/lib/gameLogic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define server-authoritative types and constants</name>
  <files>src/shared/types.ts, src/shared/constants.ts</files>
  <action>
    Create `src/shared/constants.ts`:
    ```typescript
    // Room configuration
    export const ROOM_CODE_LENGTH = 6;
    export const ROOM_CODE_ALPHABET = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No 0/O, 1/I/l

    // Game configuration
    export const MIN_PLAYERS = 2;
    export const MAX_PLAYERS = 6;
    export const STARTING_DICE = 5;
    export const MAX_DICE = 5;

    // Turn configuration
    export const DEFAULT_TURN_TIMEOUT_MS = 30000; // 30 seconds
    export const RECONNECT_GRACE_PERIOD_MS = 60000; // 60 seconds
    ```

    Create `src/shared/types.ts` with server-authoritative types:

    1. **PlayerColor** - reuse from existing src/lib/types.ts:
       `'blue' | 'green' | 'orange' | 'yellow' | 'black' | 'red'`

    2. **GamePhase** - server-authoritative phases:
       `'lobby' | 'rolling' | 'bidding' | 'reveal' | 'ended'`

    3. **Bid** - same as existing:
       ```typescript
       interface Bid {
         count: number;
         value: number; // 1-6
       }
       ```

    4. **ServerPlayer** - server's view of a player:
       ```typescript
       interface ServerPlayer {
         id: string;           // Connection ID from PartyKit
         name: string;         // Display name (2-12 chars)
         color: PlayerColor;
         diceCount: number;    // Current dice remaining
         hand: number[];       // Dice values (only sent to owner)
         isConnected: boolean; // WebSocket connected
         isEliminated: boolean;
         isHost: boolean;
       }
       ```

    5. **GameSettings** - configurable game options:
       ```typescript
       interface GameSettings {
         startingDice: number;     // Default 5
         palificoEnabled: boolean; // Wild ones rule
         turnTimeoutMs: number;    // Per-turn timer
       }
       ```

    6. **ServerGameState** - server's canonical game state:
       ```typescript
       interface ServerGameState {
         phase: GamePhase;
         players: ServerPlayer[];
         currentBid: Bid | null;
         currentTurnPlayerId: string | null;
         roundStarterId: string | null;
         lastBidderId: string | null;
         isPalifico: boolean;
         roundNumber: number;
         turnStartedAt: number | null;  // For turn timer
       }
       ```

    7. **ServerRoomState** - complete room state:
       ```typescript
       interface ServerRoomState {
         roomCode: string;
         hostId: string;
         players: ServerPlayer[];
         gameState: ServerGameState | null; // null when in lobby
         settings: GameSettings;
         createdAt: number;
       }
       ```

    8. **PublicPlayerState** - what other players can see (no hand):
       ```typescript
       type PublicPlayerState = Omit<ServerPlayer, 'hand'>;
       ```

    Export all types. Note: these are SERVER-AUTHORITATIVE types - the source of truth lives on the server.
  </action>
  <verify>
    Run `npx tsc --noEmit src/shared/types.ts src/shared/constants.ts` - should compile without errors.
    Run `grep -c "export" src/shared/types.ts` - should show 8+ exports.
  </verify>
  <done>
    - src/shared/constants.ts defines room, game, and turn configuration constants
    - src/shared/types.ts defines ServerPlayer, ServerGameState, ServerRoomState, GameSettings, PublicPlayerState
    - All types compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Define Zod message protocol schemas</name>
  <files>src/shared/messages.ts, src/shared/index.ts</files>
  <action>
    Create `src/shared/messages.ts` with Zod discriminated unions:

    **Client -> Server Messages (intentions):**
    ```typescript
    import { z } from 'zod';

    // Shared schemas
    const BidSchema = z.object({
      count: z.number().int().min(1),
      value: z.number().int().min(1).max(6),
    });

    const TimestampSchema = z.number(); // Unix timestamp ms

    // Client messages - what clients send to server
    export const ClientMessageSchema = z.discriminatedUnion('type', [
      z.object({
        type: z.literal('JOIN_ROOM'),
        playerName: z.string().min(2).max(12),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('LEAVE_ROOM'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('START_GAME'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('ROLL_DICE'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('PLACE_BID'),
        bid: BidSchema,
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('CALL_DUDO'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('CALL_CALZA'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('CONTINUE_ROUND'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('UPDATE_SETTINGS'),
        settings: z.object({
          startingDice: z.number().int().min(1).max(5).optional(),
          palificoEnabled: z.boolean().optional(),
          turnTimeoutMs: z.number().int().min(10000).max(120000).optional(),
        }),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('KICK_PLAYER'),
        playerId: z.string(),
        timestamp: TimestampSchema,
      }),
    ]);

    export type ClientMessage = z.infer<typeof ClientMessageSchema>;
    ```

    **Server -> Client Messages (state updates):**
    ```typescript
    // Error types - structured for client handling (per CONTEXT.md decision)
    export const GameErrorSchema = z.discriminatedUnion('type', [
      z.object({
        type: z.literal('INVALID_BID'),
        reason: z.string(),
        currentBid: BidSchema.nullable(),
      }),
      z.object({
        type: z.literal('NOT_YOUR_TURN'),
        reason: z.string(),
        currentPlayerId: z.string().nullable(),
      }),
      z.object({
        type: z.literal('GAME_NOT_STARTED'),
        reason: z.string(),
      }),
      z.object({
        type: z.literal('ROOM_FULL'),
        reason: z.string(),
        maxPlayers: z.number(),
      }),
      z.object({
        type: z.literal('INVALID_ACTION'),
        reason: z.string(),
      }),
      z.object({
        type: z.literal('NOT_HOST'),
        reason: z.string(),
      }),
      z.object({
        type: z.literal('INVALID_NAME'),
        reason: z.string(),
      }),
    ]);

    export type GameError = z.infer<typeof GameErrorSchema>;

    // Server messages - what server sends to clients
    export const ServerMessageSchema = z.discriminatedUnion('type', [
      z.object({
        type: z.literal('ROOM_STATE'),
        state: z.any(), // ServerRoomState - use any to avoid circular imports
        yourPlayerId: z.string(),
        yourHand: z.array(z.number()).optional(), // Only sent to owner
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('GAME_STATE'),
        state: z.any(), // ServerGameState
        yourHand: z.array(z.number()).optional(),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('PLAYER_JOINED'),
        player: z.any(), // PublicPlayerState
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('PLAYER_LEFT'),
        playerId: z.string(),
        reason: z.enum(['left', 'kicked', 'disconnected']),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('GAME_STARTED'),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('DICE_ROLLED'),
        yourHand: z.array(z.number()), // Your dice values
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('BID_PLACED'),
        playerId: z.string(),
        bid: BidSchema,
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('DUDO_CALLED'),
        callerId: z.string(),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('CALZA_CALLED'),
        callerId: z.string(),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('ROUND_RESULT'),
        bid: BidSchema,
        actualCount: z.number(),
        allHands: z.record(z.string(), z.array(z.number())), // All players' dice revealed
        loserId: z.string().nullable(), // Who loses a die (null for calza success)
        winnerId: z.string().nullable(), // Who gains a die (calza only)
        isCalza: z.boolean(),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('GAME_ENDED'),
        winnerId: z.string(),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('TURN_TIMEOUT'),
        playerId: z.string(),
        aiAction: z.enum(['bid', 'dudo']),
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('ERROR'),
        error: GameErrorSchema,
        timestamp: TimestampSchema,
      }),
      z.object({
        type: z.literal('SETTINGS_UPDATED'),
        settings: z.any(), // GameSettings
        timestamp: TimestampSchema,
      }),
    ]);

    export type ServerMessage = z.infer<typeof ServerMessageSchema>;
    ```

    Create `src/shared/index.ts` barrel export:
    ```typescript
    // Types
    export * from './types';

    // Constants
    export * from './constants';

    // Message schemas and types
    export {
      ClientMessageSchema,
      ServerMessageSchema,
      GameErrorSchema,
      type ClientMessage,
      type ServerMessage,
      type GameError,
    } from './messages';
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit src/shared/messages.ts` - should compile without errors.
    Run `grep "z.discriminatedUnion" src/shared/messages.ts` - should find ClientMessageSchema and ServerMessageSchema.
    Run `grep "timestamp" src/shared/messages.ts | wc -l` - should show timestamps on all messages (15+).
  </verify>
  <done>
    - src/shared/messages.ts defines ClientMessageSchema with 10 message types
    - src/shared/messages.ts defines ServerMessageSchema with 14 message types
    - src/shared/messages.ts defines GameErrorSchema with 7 error types
    - All messages include timestamp field (per CONTEXT.md decision)
    - Error types are structured objects with type and reason (per CONTEXT.md decision)
    - src/shared/index.ts exports all types, constants, and schemas
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit src/shared/**/*.ts` - all files compile
2. `grep "export" src/shared/types.ts src/shared/messages.ts | wc -l` - shows 20+ exports
3. `grep "timestamp" src/shared/messages.ts | wc -l` - shows timestamps on all messages
4. Import test: `echo "import { ServerRoomState, ClientMessageSchema } from './src/shared';" | npx tsc --noEmit --esModuleInterop --moduleResolution node --module esnext --target esnext /dev/stdin` - should work
</verification>

<success_criteria>
- ServerGameState, ServerPlayer, ServerRoomState, GameSettings types defined
- ClientMessageSchema covers: JOIN_ROOM, LEAVE_ROOM, START_GAME, ROLL_DICE, PLACE_BID, CALL_DUDO, CALL_CALZA, CONTINUE_ROUND, UPDATE_SETTINGS, KICK_PLAYER
- ServerMessageSchema covers: ROOM_STATE, GAME_STATE, PLAYER_JOINED, PLAYER_LEFT, GAME_STARTED, DICE_ROLLED, BID_PLACED, DUDO_CALLED, CALZA_CALLED, ROUND_RESULT, GAME_ENDED, TURN_TIMEOUT, ERROR, SETTINGS_UPDATED
- All messages have timestamp field
- Error messages use structured { type, reason } format
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-architecture-foundation/01-02-SUMMARY.md`
</output>

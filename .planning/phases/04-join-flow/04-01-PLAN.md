---
phase: 04-join-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/messages.ts
  - src/hooks/useClientIdentity.ts
  - src/hooks/useRoomConnection.ts
  - party/index.ts
autonomous: true

must_haves:
  truths:
    - "Server sends ROOM_INFO to new connecting clients with room status"
    - "Server recognizes returning users by client ID and auto-rejoins them"
    - "Server validates nickname uniqueness before allowing join"
    - "Server creates room state on first JOIN_ROOM and assigns host"
    - "Client ID persists across page refreshes in localStorage"
  artifacts:
    - path: "src/hooks/useClientIdentity.ts"
      provides: "Client ID generation and persistence"
      exports: ["useClientIdentity"]
    - path: "src/shared/messages.ts"
      provides: "ROOM_INFO and PLAYER_RECONNECTED message schemas"
      contains: "ROOM_INFO"
    - path: "party/index.ts"
      provides: "Full join flow implementation"
      contains: "handleJoinRoom"
  key_links:
    - from: "src/hooks/useRoomConnection.ts"
      to: "useClientIdentity"
      via: "id option in usePartySocket"
      pattern: "id:\\s*clientId"
    - from: "party/index.ts"
      to: "ROOM_INFO broadcast"
      via: "onConnect sends ROOM_INFO to new users"
      pattern: "type.*ROOM_INFO"
---

<objective>
Server-side join flow infrastructure with client identity persistence

Purpose: Enable the server to handle JOIN_ROOM messages with full validation (room state, capacity, duplicate nicknames) and recognize returning users for auto-rejoin. Establishes client identity via localStorage + nanoid for stable reconnection.

Output: Working PartyKit server that creates rooms on first join, validates nicknames, broadcasts player events, and distinguishes new vs returning users.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-join-flow/04-CONTEXT.md
@.planning/phases/04-join-flow/04-RESEARCH.md

# Existing code to extend
@src/shared/messages.ts
@src/shared/types.ts
@src/hooks/useRoomConnection.ts
@party/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ROOM_INFO message schema and useClientIdentity hook</name>
  <files>
    src/shared/messages.ts
    src/hooks/useClientIdentity.ts
  </files>
  <action>
1. In `src/shared/messages.ts`, add two new message types to ServerMessageSchema:

```typescript
// Add to ServerMessageSchema discriminated union
z.object({
  type: z.literal('ROOM_INFO'),
  roomCode: z.string(),
  playerCount: z.number(),
  maxPlayers: z.number(),
  gameInProgress: z.boolean(),
  timestamp: TimestampSchema,
}),
z.object({
  type: z.literal('PLAYER_RECONNECTED'),
  playerId: z.string(),
  playerName: z.string(),
  timestamp: TimestampSchema,
}),
```

2. Create `src/hooks/useClientIdentity.ts`:

```typescript
'use client';

import { useEffect, useState } from 'react';
import { nanoid } from 'nanoid';

const CLIENT_ID_KEY = 'perudo-client-id';

/**
 * Hook for persistent client identity across sessions.
 * Generates a unique ID on first visit, stores in localStorage.
 * Returns null during SSR, then the stable ID after hydration.
 */
export function useClientIdentity(): string | null {
  const [clientId, setClientId] = useState<string | null>(null);

  useEffect(() => {
    let id = localStorage.getItem(CLIENT_ID_KEY);
    if (!id) {
      id = nanoid(); // 21 chars, collision-proof
      localStorage.setItem(CLIENT_ID_KEY, id);
    }
    setClientId(id);
  }, []);

  return clientId;
}
```
  </action>
  <verify>
    - `npm run lint` passes
    - `grep -r "ROOM_INFO" src/shared/` finds the new message type
    - `grep -r "useClientIdentity" src/hooks/` finds the hook
  </verify>
  <done>
    ROOM_INFO and PLAYER_RECONNECTED message schemas added. useClientIdentity hook created and exports correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useRoomConnection to use client identity</name>
  <files>src/hooks/useRoomConnection.ts</files>
  <action>
Update useRoomConnection to accept an optional clientId parameter and pass it to usePartySocket.

Changes:
1. Add `clientId` to UseRoomConnectionOptions interface (optional string)
2. Pass `id: clientId` to usePartySocket options when clientId is provided
3. Only connect when clientId is defined (prevents connection before hydration)

```typescript
interface UseRoomConnectionOptions {
  roomCode: string;
  clientId?: string | null; // Pass from useClientIdentity
  onMessage?: (message: ServerMessage) => void;
  onStatusChange?: (status: ConnectionStatus) => void;
}

export function useRoomConnection({ roomCode, clientId, onMessage, onStatusChange }: UseRoomConnectionOptions) {
  // ... existing status state ...

  const ws = usePartySocket({
    host: process.env.NEXT_PUBLIC_PARTYKIT_HOST!,
    room: normalizeRoomCode(roomCode),
    id: clientId ?? undefined, // Custom connection ID for reconnection

    // ... existing handlers ...
  });

  return { ws, status };
}
```

Note: When clientId is null (SSR or before hydration), usePartySocket will generate a random ID. This is OK because the client will reconnect with the correct ID after hydration. However, for better UX, consider conditionally rendering the connection only after clientId is available (handled in room page).
  </action>
  <verify>
    - `npm run lint` passes
    - `grep "id:" src/hooks/useRoomConnection.ts` shows the id option being passed
  </verify>
  <done>
    useRoomConnection accepts clientId parameter and passes it to PartySocket for stable identity.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement full join flow in PartyKit server</name>
  <files>party/index.ts</files>
  <action>
Implement the complete join flow in party/index.ts:

1. Add MAX_PLAYERS constant at top: `const MAX_PLAYERS = 6;`

2. Update `onConnect` to send ROOM_INFO for new users:
```typescript
async onConnect(connection: Party.Connection, ctx: Party.ConnectionContext): Promise<void> {
  connection.setState({ connectedAt: Date.now() });

  if (this.roomState) {
    // Check if returning player
    const existingPlayer = this.roomState.players.find(p => p.id === connection.id);
    if (existingPlayer) {
      // Returning user - update connection, send state
      existingPlayer.isConnected = true;
      await this.persistState();

      this.sendToConnection(connection, {
        type: 'ROOM_STATE',
        state: this.getPublicRoomState(),
        yourPlayerId: connection.id,
        yourHand: existingPlayer.hand,
        timestamp: Date.now(),
      });

      // Notify others of reconnection
      this.broadcast({
        type: 'PLAYER_RECONNECTED',
        playerId: connection.id,
        playerName: existingPlayer.name,
        timestamp: Date.now(),
      }, [connection.id]);
      return;
    }
  }

  // New user - send room info for join form
  const connectedCount = this.roomState?.players.filter(p => p.isConnected).length ?? 0;
  const gameInProgress = this.roomState?.gameState !== null && this.roomState?.gameState?.phase !== 'lobby';

  this.sendToConnection(connection, {
    type: 'ROOM_INFO',
    roomCode: this.room.id,
    playerCount: connectedCount,
    maxPlayers: MAX_PLAYERS,
    gameInProgress: gameInProgress ?? false,
    timestamp: Date.now(),
  });
}
```

3. Implement `handleJoinRoom` with full validation:
```typescript
private async handleJoinRoom(
  msg: Extract<ClientMessage, { type: 'JOIN_ROOM' }>,
  sender: Party.Connection
): Promise<void> {
  const { playerName } = msg;

  // Validate nickname on server (trust but verify)
  if (playerName.length < 2 || playerName.length > 12) {
    this.sendError(sender, 'INVALID_NAME', 'Nickname must be 2-12 characters.');
    return;
  }

  if (!this.roomState) {
    // First player creates room and becomes host
    this.roomState = {
      roomCode: this.room.id,
      hostId: sender.id,
      players: [],
      gameState: null,
      settings: DEFAULT_SETTINGS,
      createdAt: Date.now(),
    };
  } else {
    // Check if already joined (shouldn't happen but defensive)
    if (this.roomState.players.some(p => p.id === sender.id && p.isConnected)) {
      // Already in room - just resend state
      this.sendToConnection(sender, {
        type: 'ROOM_STATE',
        state: this.getPublicRoomState(),
        yourPlayerId: sender.id,
        timestamp: Date.now(),
      });
      return;
    }

    // Check for duplicate nickname (case-insensitive)
    const duplicateName = this.roomState.players.some(
      p => p.name.toLowerCase() === playerName.toLowerCase() && p.isConnected
    );
    if (duplicateName) {
      this.sendError(sender, 'INVALID_NAME', 'This name is taken. Choose another.');
      return;
    }

    // Check room capacity
    const connectedCount = this.roomState.players.filter(p => p.isConnected).length;
    if (connectedCount >= MAX_PLAYERS) {
      this.sendError(sender, 'ROOM_FULL', `Room is full (${MAX_PLAYERS}/${MAX_PLAYERS} players).`);
      return;
    }

    // Check game state
    if (this.roomState.gameState !== null && this.roomState.gameState.phase !== 'lobby') {
      this.sendError(sender, 'INVALID_ACTION', 'Game in progress. Wait until it ends.');
      return;
    }
  }

  // Assign color (first available from list)
  const usedColors = new Set(this.roomState.players.map(p => p.color));
  const availableColors: Array<'blue' | 'green' | 'orange' | 'yellow' | 'black' | 'red'> =
    ['blue', 'green', 'orange', 'yellow', 'black', 'red'];
  const color = availableColors.find(c => !usedColors.has(c)) ?? 'blue';

  // Create player
  const newPlayer: ServerPlayer = {
    id: sender.id,
    name: playerName,
    color,
    diceCount: this.roomState.settings.startingDice,
    hand: [],
    isConnected: true,
    isEliminated: false,
    isHost: this.roomState.players.length === 0, // First player is host
  };

  this.roomState.players.push(newPlayer);
  await this.persistState();

  // Send full state to joiner
  this.sendToConnection(sender, {
    type: 'ROOM_STATE',
    state: this.getPublicRoomState(),
    yourPlayerId: sender.id,
    timestamp: Date.now(),
  });

  // Notify others
  this.broadcast({
    type: 'PLAYER_JOINED',
    player: { ...newPlayer, hand: [] }, // Don't leak hand
    timestamp: Date.now(),
  }, [sender.id]);
}
```

4. Import ServerPlayer type at top:
```typescript
import {
  // ... existing imports ...
  type ServerPlayer,
} from '../src/shared';
```
  </action>
  <verify>
    - `npm run lint` passes
    - `npx partykit dev` starts without errors (in background, then stop)
    - Code review: handleJoinRoom validates nickname, checks duplicates, checks capacity, checks game state
  </verify>
  <done>
    PartyKit server implements full join flow: onConnect sends ROOM_INFO to new users and ROOM_STATE to returning users. handleJoinRoom validates nicknames, creates rooms, assigns colors, broadcasts PLAYER_JOINED.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run lint` passes with no errors
2. TypeScript compilation: `npm run build` or `npx tsc --noEmit` succeeds
3. Message schema includes ROOM_INFO and PLAYER_RECONNECTED types
4. Server handles JOIN_ROOM with validation for all error cases
5. Client identity hook ready for use in room page
</verification>

<success_criteria>
- Server sends ROOM_INFO on new connection with player count and game status
- Server recognizes returning users by connection.id and auto-sends ROOM_STATE
- JOIN_ROOM validates: nickname length, duplicate names (case-insensitive), room capacity (6), game in progress
- First player to join becomes host
- Players assigned unique colors from available pool
- PLAYER_JOINED broadcast to existing players when someone joins
- PLAYER_RECONNECTED broadcast when returning player reconnects
- Client identity persists across page refreshes via localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/04-join-flow/04-01-SUMMARY.md`
</output>

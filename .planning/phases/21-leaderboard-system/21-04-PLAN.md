---
phase: 21-leaderboard-system
plan: 04
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - workers/leaderboard-reset/index.ts
  - workers/leaderboard-reset/wrangler.toml
autonomous: true
user_setup:
  - service: Cloudflare Workers
    why: "Separate worker for scheduled leaderboard reset (PartyKit doesn't support cron triggers)"
    env_vars: []
    dashboard_config:
      - task: "Deploy the reset worker"
        location: "Run: cd workers/leaderboard-reset && npx wrangler deploy"
        note: "Worker must share the same D1 database binding as the main PartyKit app"

must_haves:
  truths:
    - "Scheduled Worker runs at midnight UTC daily"
    - "Reset deletes all entries from leaderboard table"
    - "Reset optionally archives top 10 to history table"
    - "Worker is deployed separately from PartyKit main app"
  artifacts:
    - path: "workers/leaderboard-reset/index.ts"
      provides: "Standalone scheduled Worker for daily leaderboard reset"
      exports: ["default"]
      contains: "scheduled"
    - path: "workers/leaderboard-reset/wrangler.toml"
      provides: "Wrangler config with cron trigger and D1 binding"
      contains: "0 0 * * *"
  key_links:
    - from: "workers/leaderboard-reset/wrangler.toml"
      to: "workers/leaderboard-reset/index.ts"
      via: "main entry point"
      pattern: "main.*index.ts"
    - from: "workers/leaderboard-reset/index.ts"
      to: "D1 database"
      via: "env.LEADERBOARD_DB"
      pattern: "env\\.LEADERBOARD_DB"
---

<objective>
Implement standalone scheduled Worker for daily leaderboard reset at midnight UTC

Purpose: Reset leaderboard daily to create fresh competition cycles (LEAD-07 reset mechanism)
Output: Separate Cloudflare Worker with cron trigger, deployed independently from PartyKit

**Architecture Note:** PartyKit deploys via `npx partykit deploy` which doesn't support Cloudflare Workers cron triggers. The scheduled reset must be a standalone Worker deployed directly via `wrangler deploy`. Both the PartyKit app and this worker share the same D1 database binding.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-leaderboard-system/21-RESEARCH.md
@.planning/phases/21-leaderboard-system/21-01-SUMMARY.md

@migrations/0001_create_leaderboard.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create standalone reset Worker directory and config</name>
  <files>workers/leaderboard-reset/wrangler.toml</files>
  <action>
Create the workers/leaderboard-reset/ directory structure.

Create wrangler.toml (NOT jsonc - standalone workers use toml):
```toml
name = "gauntlet-leaderboard-reset"
main = "index.ts"
compatibility_date = "2024-01-01"

# Cron trigger for midnight UTC daily
[triggers]
crons = ["0 0 * * *"]

# D1 database binding - same database as PartyKit app
[[d1_databases]]
binding = "LEADERBOARD_DB"
database_name = "gauntlet-leaderboard"
database_id = "YOUR_DATABASE_ID_HERE"
```

Note: The database_id must match the one in the main wrangler.jsonc from Plan 21-01.
  </action>
  <verify>`cat workers/leaderboard-reset/wrangler.toml` shows crons array and d1_databases binding</verify>
  <done>Wrangler config exists with cron trigger "0 0 * * *" and D1 binding</done>
</task>

<task type="auto">
  <name>Task 2: Create scheduled reset Worker</name>
  <files>workers/leaderboard-reset/index.ts</files>
  <action>
Create standalone Cloudflare Worker for daily reset:

```typescript
interface Env {
  LEADERBOARD_DB: D1Database;
}

export default {
  async scheduled(
    controller: ScheduledController,
    env: Env,
    ctx: ExecutionContext
  ): Promise<void> {
    console.log('[CRON] Daily leaderboard reset triggered at', new Date().toISOString());

    const db = env.LEADERBOARD_DB;

    try {
      // Archive yesterday's top 10 (if history table exists)
      // This may fail if history table doesn't exist - that's OK for MVP
      try {
        await db.prepare(`
          INSERT INTO leaderboard_history (nickname, score, date, rank)
          SELECT
            nickname,
            score,
            date('now', '-1 day'),
            ROW_NUMBER() OVER (ORDER BY score DESC, id ASC)
          FROM leaderboard
          ORDER BY score DESC, id ASC
          LIMIT 10
        `).run();
        console.log('[CRON] Archived top 10 to history');
      } catch (archiveError) {
        // History table may not exist - continue with reset
        console.log('[CRON] Archive skipped (history table may not exist):', archiveError);
      }

      // Delete all entries from current leaderboard
      const result = await db.prepare('DELETE FROM leaderboard').run();

      console.log('[CRON] Reset complete. Deleted', result.meta.changes, 'entries');
    } catch (error) {
      console.error('[CRON] Reset failed:', error);
      throw error; // Re-throw to mark cron as failed in Cloudflare dashboard
    }
  },

  // Optional: HTTP handler for manual trigger/testing
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // Health check
    if (url.pathname === '/health') {
      return new Response(JSON.stringify({
        status: 'ok',
        worker: 'leaderboard-reset',
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Manual trigger (protected - could add auth header check)
    if (url.pathname === '/trigger' && request.method === 'POST') {
      try {
        await this.scheduled({} as ScheduledController, env, {} as ExecutionContext);
        return new Response(JSON.stringify({ success: true, message: 'Reset triggered' }), {
          headers: { 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({ success: false, error: String(error) }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }

    return new Response('Leaderboard Reset Worker', { status: 200 });
  }
};
```

Notes:
- Use ROW_NUMBER() window function for ranking in archive
- Archive INSERT wrapped in try/catch - may fail if history table doesn't exist
- Log entry count for debugging
- Re-throw errors so Cloudflare marks the cron execution as failed
- Optional fetch handler allows manual trigger for testing
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit workers/leaderboard-reset/index.ts`</verify>
  <done>Scheduled Worker archives top 10 and clears leaderboard</done>
</task>

</tasks>

<verification>
1. Directory structure exists: `ls -la workers/leaderboard-reset/`
2. Reset Worker compiles: `cd workers/leaderboard-reset && npx tsc --noEmit index.ts`
3. Cron configured: `grep "0 0" workers/leaderboard-reset/wrangler.toml`
4. Scheduled export exists: `grep "scheduled" workers/leaderboard-reset/index.ts`
5. D1 binding configured: `grep "LEADERBOARD_DB" workers/leaderboard-reset/wrangler.toml`
</verification>

<success_criteria>
- [ ] workers/leaderboard-reset/ directory exists
- [ ] workers/leaderboard-reset/index.ts exports scheduled handler
- [ ] Handler archives top 10 to history table (with graceful failure if table missing)
- [ ] Handler deletes all current leaderboard entries
- [ ] workers/leaderboard-reset/wrangler.toml includes cron trigger "0 0 * * *"
- [ ] wrangler.toml has same D1 database binding as main app
- [ ] TypeScript compiles without errors
- [ ] All files committed to git
</success_criteria>

<checkpoint type="human-action" gate="blocking">
  <action>Deploy the scheduled reset worker</action>
  <instructions>
The reset worker must be deployed separately from the PartyKit app:

1. Update the database_id in workers/leaderboard-reset/wrangler.toml to match the one from wrangler.jsonc

2. Deploy the worker:
```bash
cd workers/leaderboard-reset
npx wrangler deploy
```

3. Verify cron is configured in Cloudflare Dashboard:
   - Go to Workers & Pages -> gauntlet-leaderboard-reset -> Triggers
   - Should show "0 0 * * *" (midnight UTC daily)

4. Optional: Test manual trigger
```bash
curl -X POST https://gauntlet-leaderboard-reset.<your-subdomain>.workers.dev/trigger
```
  </instructions>
  <resume-signal>Type "reset worker deployed" when deployment is complete and cron trigger is visible in dashboard</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/21-leaderboard-system/21-04-SUMMARY.md`
</output>

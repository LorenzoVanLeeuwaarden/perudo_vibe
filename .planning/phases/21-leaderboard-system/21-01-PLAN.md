---
phase: 21-leaderboard-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/0001_create_leaderboard.sql
  - party/leaderboard.ts
  - partykit.json
  - wrangler.jsonc
autonomous: true
user_setup:
  - service: Cloudflare D1
    why: "Serverless database for leaderboard storage"
    env_vars: []
    dashboard_config:
      - task: "Create D1 database named 'gauntlet-leaderboard'"
        location: "Cloudflare Dashboard -> Workers & Pages -> D1 or run: npx wrangler d1 create gauntlet-leaderboard"
        note: "Copy database_id from output to wrangler.jsonc"

must_haves:
  truths:
    - "D1 database 'gauntlet-leaderboard' exists and is bound to Worker"
    - "Leaderboard Worker responds to HTTP requests at /party/leaderboard"
    - "Schema has leaderboard table with proper indexes"
  artifacts:
    - path: "migrations/0001_create_leaderboard.sql"
      provides: "D1 schema with leaderboard table"
      contains: "CREATE TABLE IF NOT EXISTS leaderboard"
    - path: "party/leaderboard.ts"
      provides: "PartyKit Worker for leaderboard operations"
      exports: ["default"]
    - path: "partykit.json"
      provides: "PartyKit configuration with leaderboard party"
      contains: "leaderboard"
    - path: "wrangler.jsonc"
      provides: "Wrangler config with D1 binding"
      contains: "LEADERBOARD_DB"
  key_links:
    - from: "party/leaderboard.ts"
      to: "wrangler.jsonc"
      via: "D1 binding"
      pattern: "LEADERBOARD_DB"
    - from: "partykit.json"
      to: "party/leaderboard.ts"
      via: "parties config"
      pattern: "leaderboard.*party/leaderboard"
---

<objective>
Set up D1 database infrastructure and leaderboard Worker skeleton

Purpose: Create the foundation for storing and querying leaderboard data with proper D1 bindings
Output: D1 schema migration, leaderboard Worker with HTTP handler, updated config files
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-leaderboard-system/21-RESEARCH.md

@partykit.json
@party/index.ts (reference only - do NOT modify)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create D1 schema migration</name>
  <files>migrations/0001_create_leaderboard.sql</files>
  <action>
Create the D1 schema migration file with:
- `leaderboard` table: id (INTEGER PRIMARY KEY AUTOINCREMENT), nickname (TEXT NOT NULL), score (INTEGER NOT NULL), submitted_at (TEXT NOT NULL DEFAULT datetime('now'))
- CHECK constraints: score >= 0 AND score <= 1000, length(nickname) <= 30
- Composite index: idx_leaderboard_score_id ON leaderboard(score DESC, id ASC) - critical for cursor pagination
- Index: idx_leaderboard_submitted_at ON leaderboard(submitted_at) - for daily filtering
- Optional: leaderboard_history table for daily archives (top 10 per day)

Create migrations/ directory if it doesn't exist.
  </action>
  <verify>File exists at migrations/0001_create_leaderboard.sql with valid SQL syntax</verify>
  <done>Schema file exists with leaderboard table, CHECK constraints, and performance indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create leaderboard Worker skeleton</name>
  <files>party/leaderboard.ts</files>
  <action>
Create PartyKit Worker for leaderboard operations:

```typescript
import type * as Party from 'partykit/server';

interface Env {
  LEADERBOARD_DB: D1Database;
}

export default class LeaderboardServer implements Party.Server {
  constructor(readonly room: Party.Room) {}

  async onRequest(request: Party.Request): Promise<Response> {
    const db = (this.room.env as Env).LEADERBOARD_DB;

    // Route based on method + path
    const url = new URL(request.url);
    const path = url.pathname;

    // Health check
    if (request.method === 'GET' && path.endsWith('/health')) {
      return new Response(JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Placeholder for future endpoints
    return new Response('Leaderboard API', { status: 200 });
  }
}
```

This is a skeleton - actual endpoints will be implemented in Plan 03.
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit party/leaderboard.ts</verify>
  <done>Leaderboard Worker exists with onRequest handler and D1 type declaration</done>
</task>

<task type="auto">
  <name>Task 3: Update PartyKit and Wrangler configuration</name>
  <files>partykit.json, wrangler.jsonc</files>
  <action>
Update partykit.json to add leaderboard party:
```json
{
  "$schema": "https://www.partykit.io/schema.json",
  "name": "faroleo",
  "main": "party/index.ts",
  "parties": {
    "leaderboard": "party/leaderboard.ts"
  },
  "compatibilityDate": "2024-01-01"
}
```

Create wrangler.jsonc with D1 binding:
```jsonc
{
  "$schema": "https://json.schemastore.org/wrangler",
  "name": "faroleo",
  "main": "party/index.ts",
  "compatibility_date": "2024-01-01",
  "d1_databases": [
    {
      "binding": "LEADERBOARD_DB",
      "database_name": "gauntlet-leaderboard",
      "database_id": "YOUR_DATABASE_ID_HERE"
    }
  ]
}
```

Note: database_id placeholder will be replaced after user creates the D1 database.
  </action>
  <verify>partykit.json has parties.leaderboard, wrangler.jsonc has d1_databases array</verify>
  <done>Both config files updated with leaderboard Worker and D1 binding configuration</done>
</task>

</tasks>

<verification>
1. Schema file exists: `cat migrations/0001_create_leaderboard.sql`
2. Worker compiles: `npx tsc --noEmit party/leaderboard.ts`
3. Config valid: `cat partykit.json | grep leaderboard` shows entry
4. D1 binding declared: `cat wrangler.jsonc | grep LEADERBOARD_DB`
</verification>

<success_criteria>
- [ ] migrations/0001_create_leaderboard.sql exists with proper schema and indexes
- [ ] party/leaderboard.ts compiles and exports default LeaderboardServer
- [ ] partykit.json includes leaderboard party entry
- [ ] wrangler.jsonc includes D1 database binding for LEADERBOARD_DB
- [ ] All files committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/21-leaderboard-system/21-01-SUMMARY.md`
</output>

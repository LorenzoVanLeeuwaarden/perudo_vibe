---
phase: 21-leaderboard-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/personal-best.ts
  - src/stores/gauntletStore.ts
autonomous: true

must_haves:
  truths:
    - "Player's personal best score is tracked in localStorage"
    - "Personal best updates automatically when player achieves higher score"
    - "Personal best persists across browser sessions"
    - "Gauntlet store exposes personal best state"
  artifacts:
    - path: "src/lib/personal-best.ts"
      provides: "localStorage wrapper for personal best tracking"
      exports: ["getPersonalBest", "updatePersonalBest", "PersonalBest"]
    - path: "src/stores/gauntletStore.ts"
      provides: "Zustand store with personal best integration"
      contains: "personalBest"
  key_links:
    - from: "src/stores/gauntletStore.ts"
      to: "src/lib/personal-best.ts"
      via: "import and call"
      pattern: "import.*personal-best"
---

<objective>
Implement client-side personal best tracking with localStorage persistence

Purpose: Track player's best Gauntlet score locally without requiring authentication (LEAD-04)
Output: Personal best utility functions, updated gauntlet store with personal best state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-leaderboard-system/21-RESEARCH.md

@src/stores/gauntletStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create personal best utility</name>
  <files>src/lib/personal-best.ts</files>
  <action>
Create localStorage wrapper for personal best tracking:

```typescript
const STORAGE_KEY = 'gauntlet_personal_best';

export interface PersonalBest {
  score: number;
  date: string;
  nickname: string;
}

export function getPersonalBest(): PersonalBest | null {
  if (typeof window === 'undefined') return null;
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
}

export function updatePersonalBest(score: number, nickname?: string): boolean {
  if (typeof window === 'undefined') return false;
  const current = getPersonalBest();

  if (!current || score > current.score) {
    const newBest: PersonalBest = {
      score,
      date: new Date().toISOString(),
      nickname: nickname || current?.nickname || 'Player'
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(newBest));
      return true; // New record
    } catch {
      return false;
    }
  }
  return false; // Not a new record
}

export function clearPersonalBest(): void {
  if (typeof window === 'undefined') return;
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore errors
  }
}
```

Key points:
- Handle SSR (typeof window check)
- Graceful error handling for storage quota or private browsing
- Return boolean from updatePersonalBest to indicate if new record set
  </action>
  <verify>File exists and exports getPersonalBest, updatePersonalBest, clearPersonalBest</verify>
  <done>Personal best utility with localStorage persistence and SSR safety</done>
</task>

<task type="auto">
  <name>Task 2: Integrate personal best into gauntlet store</name>
  <files>src/stores/gauntletStore.ts</files>
  <action>
Update gauntlet store to:

1. Add personalBest state field
2. Load personal best on store initialization (hydration)
3. Check/update personal best when game ends

Add to interface:
```typescript
personalBest: PersonalBest | null;
loadPersonalBest: () => void;
checkPersonalBest: () => boolean;
```

Add import at top:
```typescript
import { getPersonalBest, updatePersonalBest, PersonalBest } from '@/lib/personal-best';
```

Add state and actions:
```typescript
personalBest: null,

loadPersonalBest: () => {
  const best = getPersonalBest();
  set({ personalBest: best });
},

checkPersonalBest: () => {
  const state = get();
  const isNewBest = updatePersonalBest(state.streak);
  if (isNewBest) {
    set({ personalBest: getPersonalBest() });
  }
  return isNewBest;
},
```

Modify setPlayerDiceCount to check personal best when transitioning to game over:
```typescript
setPlayerDiceCount: (count: number) => {
  if (count === 0) {
    // Check personal best before transitioning to game over
    const state = get();
    const isNewBest = updatePersonalBest(state.streak);
    set({
      playerDiceCount: count,
      screen: 'gameOver',
      personalBest: isNewBest ? getPersonalBest() : state.personalBest
    });
  } else {
    set({ playerDiceCount: count });
  }
},
```

Also update loseDie action similarly to check personal best when playerDiceCount hits 0.
  </action>
  <verify>`npm run lint -- --quiet src/stores/gauntletStore.ts` passes with no errors</verify>
  <done>Gauntlet store tracks personal best with auto-update on game over</done>
</task>

</tasks>

<verification>
1. Utility exports correctly: `grep -E "export (function|interface)" src/lib/personal-best.ts`
2. Store imports utility: `grep "personal-best" src/stores/gauntletStore.ts`
3. No TypeScript errors: `npx tsc --noEmit`
4. No lint errors: `npm run lint -- --quiet`
</verification>

<success_criteria>
- [ ] src/lib/personal-best.ts exports PersonalBest type and utility functions
- [ ] gauntletStore.ts has personalBest state field
- [ ] Personal best auto-updates when game ends with new high score
- [ ] SSR-safe (no localStorage errors during server rendering)
- [ ] All files committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/21-leaderboard-system/21-02-SUMMARY.md`
</output>

---
phase: 09-social-and-polish
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - src/app/room/[code]/page.tsx
  - src/components/GameBoard.tsx
autonomous: true

must_haves:
  truths:
    - "EMOTE_RECEIVED messages trigger emote bubbles above player badges"
    - "GAME_ENDED with stats triggers celebration then results screen"
    - "Host clicking Return to Lobby sends RETURN_TO_LOBBY and all players see lobby"
    - "Emote pop sound plays when emote is received"
    - "Full game flow works: play -> game end -> celebration -> stats -> rematch"
  artifacts:
    - path: "src/app/room/[code]/page.tsx"
      provides: "Complete message handling for emotes, game end, and return to lobby"
      contains: "EMOTE_RECEIVED"
    - path: "src/components/GameBoard.tsx"
      provides: "Integration of celebration and results screen flow"
      contains: "GameResultsScreen"
  key_links:
    - from: "src/app/room/[code]/page.tsx"
      to: "uiStore.addEmote"
      via: "EMOTE_RECEIVED handler"
      pattern: "addEmote.*emote"
    - from: "src/app/room/[code]/page.tsx"
      to: "RETURN_TO_LOBBY"
      via: "sendMessage in onReturnToLobby"
      pattern: "RETURN_TO_LOBBY"
---

<objective>
Wire all Phase 9 components together for complete social and polish integration.

Purpose: Connect emote message handling, game end flow with celebration and stats, and rematch via return-to-lobby into a seamless experience.

Output: Fully integrated social features and polished game-end flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-social-and-polish/09-CONTEXT.md
@.planning/phases/09-social-and-polish/09-01-SUMMARY.md
@.planning/phases/09-social-and-polish/09-02-SUMMARY.md
@.planning/phases/09-social-and-polish/09-03-SUMMARY.md
@src/app/room/[code]/page.tsx
@src/components/GameBoard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message handlers in room page for emotes and game end</name>
  <files>src/app/room/[code]/page.tsx</files>
  <action>
Update the room page to handle new message types:

1. Import necessary hooks and store actions:
```typescript
import { useUIStore } from '@/stores/uiStore';
import { useSoundEffects } from '@/hooks/useSoundEffects';
```

2. Add state for game stats (needed for results screen):
```typescript
const [gameStats, setGameStats] = useState<GameStats | null>(null);
const [showCelebration, setShowCelebration] = useState(false);
const [showResults, setShowResults] = useState(false);
```

3. Get addEmote from uiStore and playPop from useSoundEffects:
```typescript
const addEmote = useUIStore(s => s.addEmote);
const { playPop } = useSoundEffects();
```

4. In the message handling switch (or wherever server messages are processed), add handlers:

For EMOTE_RECEIVED:
```typescript
case 'EMOTE_RECEIVED':
  addEmote(msg.playerId, msg.emote);
  playPop(); // Play pop sound for received emote
  break;
```

For GAME_ENDED (update existing handler if present):
```typescript
case 'GAME_ENDED':
  // Store stats for results screen
  setGameStats(msg.stats);
  // Show celebration first
  setShowCelebration(true);
  // After 8 seconds (per CONTEXT.md), show results
  setTimeout(() => {
    setShowCelebration(false);
    setShowResults(true);
  }, 8000);
  break;
```

For ROOM_STATE (when returning to lobby after rematch):
```typescript
case 'ROOM_STATE':
  // Clear celebration/results state when returning to lobby
  setShowCelebration(false);
  setShowResults(false);
  setGameStats(null);
  // ... existing room state handling ...
  break;
```

5. Add handler for return to lobby button:
```typescript
const handleReturnToLobby = () => {
  sendMessage({ type: 'RETURN_TO_LOBBY', timestamp: Date.now() });
};
```

6. Add handler for leaving game:
```typescript
const handleLeaveGame = () => {
  // Navigate back to home
  window.location.href = '/';
};
```

7. Import GameStats type from shared types.
  </action>
  <verify>Run `npx tsc --noEmit` - room page compiles with new handlers</verify>
  <done>Room page handles EMOTE_RECEIVED (adds emote, plays pop sound), GAME_ENDED (stores stats, triggers celebration -> results flow), ROOM_STATE (clears celebration state on lobby return). Return to lobby and leave game handlers ready.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate celebration and results flow into GameBoard</name>
  <files>src/components/GameBoard.tsx</files>
  <action>
Update GameBoard to receive and render celebration/results components:

1. Update GameBoardProps to include new props:
```typescript
interface GameBoardProps {
  roomState: ServerRoomState;
  myPlayerId: string;
  myHand: number[];
  sendMessage: (msg: ClientMessage) => void;
  // New props for celebration/results flow
  showCelebration?: boolean;
  showResults?: boolean;
  gameStats?: GameStats | null;
  onCelebrationComplete?: () => void;
  onReturnToLobby?: () => void;
  onLeaveGame?: () => void;
}
```

2. Import VictoryScreen and GameResultsScreen:
```typescript
import { VictoryScreen } from './VictoryScreen';
import { GameResultsScreen } from './GameResultsScreen';
```

3. Determine if current player is winner and is host:
```typescript
const winnerId = gameStats?.winnerId;
const isWinner = winnerId === myPlayerId;
const isHost = roomState.hostId === myPlayerId;
```

4. At the end of the component (after all existing JSX), add celebration and results overlays:
```typescript
{/* Victory celebration for winner */}
{showCelebration && isWinner && (
  <VictoryScreen
    playerColor={myColor}
    onPlayAgain={onCelebrationComplete || (() => {})}
  />
)}

{/* Results screen for all players after celebration */}
{showResults && gameStats && (
  <GameResultsScreen
    stats={gameStats}
    players={players.map(p => ({
      id: p.id,
      name: p.name,
      color: p.color as PlayerColor,
    }))}
    isHost={isHost}
    onReturnToLobby={onReturnToLobby || (() => {})}
    onLeaveGame={onLeaveGame || (() => {})}
  />
)}
```

5. For non-winners during celebration, show a simple waiting screen:
```typescript
{/* Waiting screen for non-winners during celebration */}
{showCelebration && !isWinner && (
  <motion.div
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    className="fixed inset-0 z-40 flex items-center justify-center"
    style={{
      background: 'radial-gradient(ellipse at center, #1a0a2e 0%, #0d0416 70%, #050208 100%)',
    }}
  >
    <div className="text-center">
      <h2 className="text-4xl font-bold text-white-soft mb-4">Game Over</h2>
      <p className="text-xl text-white-soft/70">
        {players.find(p => p.id === winnerId)?.name} wins!
      </p>
      <p className="text-white-soft/50 mt-4">Loading results...</p>
    </div>
  </motion.div>
)}
```

6. Import motion from framer-motion if not already imported (it should be).

7. Import type GameStats from shared:
```typescript
import type { GameStats } from '@/shared';
```
  </action>
  <verify>Run `npx tsc --noEmit` - GameBoard compiles with celebration and results integration</verify>
  <done>GameBoard renders VictoryScreen for winner during celebration, waiting screen for non-winners, GameResultsScreen for all after celebration. Props passed through for return to lobby and leave game actions.</done>
</task>

<task type="auto">
  <name>Task 3: Update room page to pass celebration props to GameBoard</name>
  <files>src/app/room/[code]/page.tsx</files>
  <action>
Update the room page to pass the new props to GameBoard:

1. Where GameBoard is rendered, add the new props:
```typescript
<GameBoard
  roomState={roomState}
  myPlayerId={myPlayerId}
  myHand={myHand}
  sendMessage={sendMessage}
  showCelebration={showCelebration}
  showResults={showResults}
  gameStats={gameStats}
  onCelebrationComplete={() => {
    setShowCelebration(false);
    setShowResults(true);
  }}
  onReturnToLobby={handleReturnToLobby}
  onLeaveGame={handleLeaveGame}
/>
```

2. Ensure all state variables are defined at the component level:
```typescript
const [showCelebration, setShowCelebration] = useState(false);
const [showResults, setShowResults] = useState(false);
const [gameStats, setGameStats] = useState<GameStats | null>(null);
```

3. Import GameStats type:
```typescript
import type { GameStats } from '@/shared';
```

4. Make sure the handleReturnToLobby and handleLeaveGame functions are defined:
```typescript
const handleReturnToLobby = useCallback(() => {
  sendMessage({ type: 'RETURN_TO_LOBBY', timestamp: Date.now() });
}, [sendMessage]);

const handleLeaveGame = useCallback(() => {
  window.location.href = '/';
}, []);
```

5. Reset celebration state when game state changes to rolling (new game started):
In the effect that handles GAME_STARTED or when gameState changes:
```typescript
// Reset celebration state on new game start
if (roomState?.gameState?.phase === 'rolling') {
  setShowCelebration(false);
  setShowResults(false);
  setGameStats(null);
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - room page compiles. Start dev server with `npm run dev` and verify no console errors on room page load.</verify>
  <done>Room page passes showCelebration, showResults, gameStats, onCelebrationComplete, onReturnToLobby, onLeaveGame to GameBoard. Celebration state resets on new game start and on return to lobby.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes without errors
2. `npm run dev` starts successfully
3. Manual test flow:
   a. Create room, join with 2 players
   b. Start game, play until one player wins
   c. Winner sees VictoryScreen with dice explosion
   d. After ~8 seconds, all players see GameResultsScreen with stats
   e. Host clicks Return to Lobby
   f. All players return to lobby with settings preserved
   g. Host can start new game (rematch)
4. Test emotes during game:
   a. Click emote picker, select emoji
   b. Emote bubble appears above player badge
   c. Pop sound plays (if sound enabled)
   d. Bubble auto-dismisses after 2 seconds
</verification>

<success_criteria>
- [ ] EMOTE_RECEIVED handler adds emote to store and plays pop sound
- [ ] GAME_ENDED handler stores stats and triggers celebration -> results flow
- [ ] Winner sees VictoryScreen with dice explosion and sounds
- [ ] Non-winners see waiting screen during celebration
- [ ] All players see GameResultsScreen after celebration (8 seconds)
- [ ] Host can click Return to Lobby to send RETURN_TO_LOBBY message
- [ ] Non-host sees "Waiting for host..." message on results screen
- [ ] ROOM_STATE received after return clears celebration state
- [ ] Leave Game button navigates to home page
- [ ] Emote bubbles display above correct player badges
- [ ] All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-social-and-polish/09-04-SUMMARY.md`
</output>

---
phase: 09-social-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/messages.ts
  - src/shared/types.ts
  - party/index.ts
autonomous: true

must_haves:
  truths:
    - "Server accepts SEND_EMOTE and broadcasts EMOTE_RECEIVED to all players"
    - "Server tracks per-player statistics during gameplay"
    - "Server sends game stats in GAME_ENDED message"
    - "Host can trigger RETURN_TO_LOBBY and all connected players return to lobby state"
  artifacts:
    - path: "src/shared/messages.ts"
      provides: "SEND_EMOTE, EMOTE_RECEIVED, RETURN_TO_LOBBY message types"
      contains: "SEND_EMOTE"
    - path: "src/shared/types.ts"
      provides: "PlayerStats and GameStats type definitions"
      contains: "PlayerStats"
    - path: "party/index.ts"
      provides: "Emote handler with cooldown, stats tracking, RETURN_TO_LOBBY handler"
      contains: "handleSendEmote"
  key_links:
    - from: "party/index.ts"
      to: "src/shared/messages.ts"
      via: "message schema import"
      pattern: "ClientMessageSchema|ServerMessageSchema"
---

<objective>
Add server-side infrastructure for emotes, statistics tracking, and rematch flow.

Purpose: Enable real-time emote broadcasting with spam prevention, track detailed game statistics for end-game display, and allow host to return all players to lobby for rematch.

Output: Extended message protocol, new types, and server handlers ready for client integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-social-and-polish/09-CONTEXT.md
@.planning/phases/09-social-and-polish/09-RESEARCH.md
@src/shared/messages.ts
@src/shared/types.ts
@party/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message types and statistics types</name>
  <files>src/shared/messages.ts, src/shared/types.ts</files>
  <action>
Update src/shared/types.ts to add:

```typescript
/**
 * Per-player game statistics tracked during gameplay
 */
export interface PlayerStats {
  bidsPlaced: number;
  dudosCalled: number;
  dudosSuccessful: number;
  calzasCalled: number;
  calzasSuccessful: number;
  diceLost: number;
  diceGained: number;
}

/**
 * Game-wide statistics sent at game end
 */
export interface GameStats {
  roundsPlayed: number;
  totalBids: number;
  winnerId: string;
  playerStats: Record<string, PlayerStats>;
}
```

Also add `stats: Record<string, PlayerStats>` field to ServerGameState interface for tracking during gameplay.

Update src/shared/messages.ts to add:

1. Client messages (add to ClientMessageSchema discriminatedUnion):
```typescript
z.object({
  type: z.literal('SEND_EMOTE'),
  emote: z.string().max(4), // Single emoji character
  timestamp: TimestampSchema,
}),
z.object({
  type: z.literal('RETURN_TO_LOBBY'),
  timestamp: TimestampSchema,
}),
```

2. Server messages (add to ServerMessageSchema discriminatedUnion):
```typescript
z.object({
  type: z.literal('EMOTE_RECEIVED'),
  playerId: z.string(),
  emote: z.string(),
  timestamp: TimestampSchema,
}),
```

3. Modify existing GAME_ENDED message to include stats:
```typescript
z.object({
  type: z.literal('GAME_ENDED'),
  winnerId: z.string(),
  stats: z.any(), // GameStats
  timestamp: TimestampSchema,
}),
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors related to message schemas or types</verify>
  <done>New message types SEND_EMOTE, EMOTE_RECEIVED, RETURN_TO_LOBBY exist in schema. PlayerStats and GameStats types defined. ServerGameState has stats field.</done>
</task>

<task type="auto">
  <name>Task 2: Add emote handler with cooldown to server</name>
  <files>party/index.ts</files>
  <action>
Add to GameServer class:

1. Add a private Map for tracking emote cooldowns:
```typescript
private playerEmoteCooldowns: Map<string, number> = new Map();
private readonly EMOTE_COOLDOWN_MS = 2500; // 2.5 seconds
```

2. Add case in onMessage switch for 'SEND_EMOTE':
```typescript
case 'SEND_EMOTE':
  await this.handleSendEmote(parsed, sender);
  break;
```

3. Add handler method:
```typescript
private async handleSendEmote(
  msg: Extract<ClientMessage, { type: 'SEND_EMOTE' }>,
  sender: Party.Connection
): Promise<void> {
  // Guard: player must be in room
  if (!this.roomState) return;
  const player = this.roomState.players.find(p => p.id === sender.id);
  if (!player) return;

  // Check cooldown (silently ignore if too frequent)
  const lastEmote = this.playerEmoteCooldowns.get(sender.id) ?? 0;
  if (Date.now() - lastEmote < this.EMOTE_COOLDOWN_MS) {
    return; // Silently ignore - no error needed for spam protection
  }

  // Update cooldown
  this.playerEmoteCooldowns.set(sender.id, Date.now());

  // Broadcast to all players
  this.broadcast({
    type: 'EMOTE_RECEIVED',
    playerId: sender.id,
    emote: msg.emote,
    timestamp: Date.now(),
  });

  console.log(`[EMOTE] ${player.name} sent emote: ${msg.emote}`);
}
```

Note: No persistence needed for emote cooldowns - they reset on server restart which is fine.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in party/index.ts</verify>
  <done>Server handles SEND_EMOTE messages, enforces 2.5s cooldown per player, broadcasts EMOTE_RECEIVED to all players.</done>
</task>

<task type="auto">
  <name>Task 3: Add statistics tracking and RETURN_TO_LOBBY handler</name>
  <files>party/index.ts</files>
  <action>
1. Initialize stats when game starts (in handleStartGame):
After setting up gameState, add:
```typescript
// Initialize per-player stats
const initialStats: Record<string, PlayerStats> = {};
for (const player of connectedPlayers) {
  initialStats[player.id] = {
    bidsPlaced: 0,
    dudosCalled: 0,
    dudosSuccessful: 0,
    calzasCalled: 0,
    calzasSuccessful: 0,
    diceLost: 0,
    diceGained: 0,
  };
}
this.roomState.gameState.stats = initialStats;
```

2. Track stats in existing handlers:
- handlePlaceBid: Increment `stats[sender.id].bidsPlaced`
- handleCallDudo: Increment `stats[sender.id].dudosCalled`, then after determining winner: if sender won, increment `dudosSuccessful`, and increment `stats[loserId].diceLost`
- handleCallCalza: Increment `stats[sender.id].calzasCalled`, then if successful increment `calzasSuccessful` and `diceGained`, else increment `diceLost`
- executeTimeoutAIMove: If AI places bid, increment `stats[player.id].bidsPlaced`. If AI calls dudo, increment `stats[player.id].dudosCalled` and track success.

3. Include stats in GAME_ENDED broadcasts (modify existing places where GAME_ENDED is broadcast):
```typescript
this.broadcast({
  type: 'GAME_ENDED',
  winnerId: remainingPlayers[0].id,
  stats: {
    roundsPlayed: gameState.roundNumber,
    totalBids: Object.values(gameState.stats).reduce((sum, s) => sum + s.bidsPlaced, 0),
    winnerId: remainingPlayers[0].id,
    playerStats: gameState.stats,
  },
  timestamp: Date.now(),
});
```

4. Add RETURN_TO_LOBBY handler:
Add case in onMessage switch:
```typescript
case 'RETURN_TO_LOBBY':
  await this.handleReturnToLobby(parsed, sender);
  break;
```

Add handler:
```typescript
private async handleReturnToLobby(
  msg: Extract<ClientMessage, { type: 'RETURN_TO_LOBBY' }>,
  sender: Party.Connection
): Promise<void> {
  if (!this.roomState) {
    this.sendError(sender, 'INVALID_ACTION', 'Room does not exist');
    return;
  }

  // Only host can initiate return to lobby
  if (this.roomState.hostId !== sender.id) {
    this.sendError(sender, 'NOT_HOST', 'Only host can return to lobby');
    return;
  }

  // Only valid from ended game state
  if (!this.roomState.gameState || this.roomState.gameState.phase !== 'ended') {
    this.sendError(sender, 'INVALID_ACTION', 'Game must be ended to return to lobby');
    return;
  }

  // Remove disconnected players from room
  this.roomState.players = this.roomState.players.filter(p => p.isConnected);

  // Reset player state for potential rematch
  for (const player of this.roomState.players) {
    player.diceCount = this.roomState.settings.startingDice;
    player.isEliminated = false;
    player.hand = [];
  }

  // Clear game state (back to lobby)
  this.roomState.gameState = null;

  // Clear any pending alarms/timers
  await this.room.storage.delete('turnTimer');
  const allKeys = await this.room.storage.list();
  for (const [key] of allKeys) {
    if (key.startsWith('disconnect_') || key.startsWith('aitakeover_')) {
      await this.room.storage.delete(key);
    }
  }

  await this.persistState();

  console.log(`[RETURN_TO_LOBBY] Host ${sender.id} returning ${this.roomState.players.length} players to lobby`);

  // Send ROOM_STATE to each connected player
  for (const conn of this.room.getConnections()) {
    const player = this.roomState.players.find(p => p.id === conn.id);
    if (player) {
      this.sendToConnection(conn, {
        type: 'ROOM_STATE',
        state: this.getPublicRoomState(),
        yourPlayerId: conn.id,
        timestamp: Date.now(),
      });
    }
  }
}
```

5. Import PlayerStats type at top of file:
```typescript
import {
  // ... existing imports ...
  type PlayerStats,
} from '../src/shared';
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors. Server can handle all new message types.</verify>
  <done>Server tracks bidsPlaced, dudosCalled, dudosSuccessful, calzasCalled, calzasSuccessful, diceLost, diceGained per player. GAME_ENDED includes full stats. RETURN_TO_LOBBY handler resets room to lobby state preserving settings and connected players.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes without errors
2. Grep for 'SEND_EMOTE' in messages.ts confirms new message type exists
3. Grep for 'PlayerStats' in types.ts confirms new type exists
4. Grep for 'handleSendEmote' in party/index.ts confirms handler exists
5. Grep for 'handleReturnToLobby' in party/index.ts confirms handler exists
</verification>

<success_criteria>
- [ ] SEND_EMOTE and RETURN_TO_LOBBY client message types added to schema
- [ ] EMOTE_RECEIVED server message type added to schema
- [ ] PlayerStats and GameStats types defined in types.ts
- [ ] ServerGameState has stats field
- [ ] Server handles SEND_EMOTE with 2.5s cooldown and broadcasts EMOTE_RECEIVED
- [ ] Server tracks per-player stats during game (bids, dudos, calzas, dice changes)
- [ ] GAME_ENDED message includes GameStats
- [ ] RETURN_TO_LOBBY handler resets room to lobby state for rematch
- [ ] All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-social-and-polish/09-01-SUMMARY.md`
</output>
